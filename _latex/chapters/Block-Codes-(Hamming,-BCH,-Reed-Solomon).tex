\section{Block Codes (Hamming, BCH,
Reed-Solomon)}\label{block-codes-hamming-bch-reed-solomon}

{[}{[}Home{]}{]} \textbar{} \textbf{Coding Theory} \textbar{}
{[}{[}Hamming-Distance-\&-Error-Detection{]}{]} \textbar{}
{[}{[}Convolutional-Codes-\&-Viterbi-Decoding{]}{]}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ For Non-Technical
Readers}{ For Non-Technical Readers}}\label{for-non-technical-readers}

\textbf{Block codes are like adding sudoku-style clues to your
message-\/-\/-if some numbers get corrupted, you can solve for the
missing ones using the patterns!}

\textbf{The idea - Add smart redundancy}: 1. Take a block of data (e.g.,
4 bits: \texttt{1011}) 2. Add parity bits using math (e.g., 3 extra
bits: \texttt{010}) 3. Send the whole thing: \texttt{1011010} (7 bits
total) 4. Receiver checks if the math works out 5. If errors detected,
use the math to FIX them!

\textbf{Three famous block codes}:

\textbf{1. Hamming Code} (invented 1950): - \textbf{Use case}: Computer
RAM error correction - \textbf{Example}: (7,4) Hamming code - 4 data
bits + 3 parity bits = 7 total - Can fix any single bit error
automatically! - \textbf{Your computer}: Uses Hamming codes in ECC RAM

\textbf{2. BCH Code} (Bose-Chaudhuri-Hocquenghem): - \textbf{Use case}:
QR codes, flash memory, DVDs - \textbf{Power}: Can fix multiple errors
in a block - \textbf{Example}: QR code can work with 30\% damaged! -
\textbf{Your phone}: Flash storage uses BCH to survive wear

\textbf{3. Reed-Solomon Code} (most powerful!): - \textbf{Use case}:
CDs, DVDs, Blu-ray, satellite TV, QR codes - \textbf{Power}: Can fix
burst errors (many consecutive bits) - \textbf{Example}: CD can have
2.5mm scratch and still play! - \textbf{Your life}: Every CD/DVD/QR code
you\textquotesingle ve used!

\textbf{How Reed-Solomon saves your music}: - \textbf{CD without
Reed-Solomon}: Tiny scratch = music skips - \textbf{CD with
Reed-Solomon}: Can fix 4000 consecutive bad bits! - This is why CDs
still play with scratches

\textbf{Real-world magic}:

\textbf{QR Code} (Reed-Solomon): - Generate QR code - Cover 30\% with
sticker - Scan \$\textbackslash rightarrow\$ STILL WORKS! - Reed-Solomon
fills in the missing parts!

\textbf{DVD scratch} (Reed-Solomon): - Scratch covers 2mm -
That\textquotesingle s \textasciitilde6000 bits corrupted -
Reed-Solomon: ``I got this'' - Movie plays perfectly

\textbf{The trade-off}: - \textbf{More redundancy} = fix more errors BUT
slower/less efficient - Hamming (7,4): 43\% overhead, fixes 1 error -
Reed-Solomon (255,223): 14\% overhead, fixes 16 errors!

\textbf{Block sizes}: - \textbf{Small blocks} (7 bits): Simple, fast,
low latency - \textbf{Large blocks} (255 bytes): Powerful, efficient,
but complex - \textbf{Huge blocks} (8192 bytes): Maximum power, used in
deep space!

\textbf{Fun fact}: The Voyager space probes (launched 1977) use
Reed-Solomon codes to transmit photos from interstellar space. With
signal so weak it\textquotesingle s barely detectable, Reed-Solomon
error correction is the ONLY reason we can still see those stunning
images!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Overview}\label{overview}

\textbf{Block codes} encode fixed-length blocks of \(k\) data symbols
into \(n\) code symbols.

\textbf{Notation}: \((n, k)\) code - \(n\) = Codeword length - \(k\) =
Message length - \(n - k\) = Redundancy (parity symbols)

\textbf{Code rate}: \(R = k/n\) (fraction of data)

\textbf{Types}: 1. \textbf{Linear block codes}: Codewords form vector
space 2. \textbf{Cyclic codes}: Codewords are cyclic shifts of each
other 3. \textbf{Non-linear codes}: More complex (less common)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Linear Block Codes}\label{linear-block-codes}

\subsubsection{Generator Matrix}\label{generator-matrix}

\textbf{Encoding}: \(\mathbf{c} = \mathbf{d} \cdot G\)

Where: - \(\mathbf{d}\) = Data vector (1\$\textbackslash times\$k) -
\(G\) = Generator matrix (k\$\textbackslash times\$n) - \(\mathbf{c}\) =
Codeword vector (1\$\textbackslash times\$n)

\textbf{Systematic form}: \(G = [I_k | P]\) - First \(k\) bits = data
(unchanged) - Last \(n-k\) bits = parity

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Parity-Check Matrix}\label{parity-check-matrix}

\textbf{Matrix} \(H\) (\((n-k) \times n\)) such that:

\[
\mathbf{c} \cdot H^T = \mathbf{0}
\]

For all valid codewords \(\mathbf{c}\)

\textbf{Systematic form}: \(H = [-P^T | I_{n-k}]\)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Syndrome Decoding}\label{syndrome-decoding}

\textbf{Receive} \(\mathbf{r} = \mathbf{c} + \mathbf{e}\) (error vector
\(\mathbf{e}\))

\textbf{Syndrome}: \(\mathbf{s} = \mathbf{r} \cdot H^T\)

\textbf{Property}: \(\mathbf{s} = \mathbf{e} \cdot H^T\) (independent of
codeword!)

\textbf{Decoding}: 1. Calculate syndrome \(\mathbf{s}\) 2. Lookup error
pattern \(\mathbf{e}\) from syndrome table 3. Correct:
\(\hat{\mathbf{c}} = \mathbf{r} - \mathbf{e}\)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Hamming Codes}\label{hamming-codes}

\textbf{Family}: \((2^m - 1, 2^m - m - 1)\) for \(m \geq 2\)

\textbf{Common examples}: - \((7, 4)\): 4 data, 3 parity - \((15, 11)\):
11 data, 4 parity - \((31, 26)\): 26 data, 5 parity

\textbf{Properties}: - \(d_{\min} = 3\) - Correct 1 error - Detect 2
errors - \textbf{Perfect code} (meets Hamming bound)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Hamming(7,4) Example}\label{hamming74-example}

\textbf{Generator matrix} (systematic form):

\[
G = \begin{bmatrix}
1 & 0 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 1 & 0 & 1 \\
0 & 0 & 1 & 0 & 0 & 1 & 1 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{bmatrix}
\]

\textbf{Parity-check matrix}:

\[
H = \begin{bmatrix}
1 & 1 & 0 & 1 & 1 & 0 & 0 \\
1 & 0 & 1 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 1 & 0 & 0 & 1
\end{bmatrix}
\]

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Encoding Example}\label{encoding-example}

\textbf{Data}: \(\mathbf{d} = [1, 0, 1, 1]\)

\textbf{Encode}:

\[
\mathbf{c} = \mathbf{d} \cdot G = [1, 0, 1, 1, 0, 0, 1]
\]

\textbf{Verification}: \(\mathbf{c} \cdot H^T = [0, 0, 0]^T\)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Decoding Example}\label{decoding-example}

\textbf{Receive}: \(\mathbf{r} = [1, 0, 1, 0, 0, 0, 1]\) (error in
position 4)

\textbf{Syndrome}:

\[
\mathbf{s} = \mathbf{r} \cdot H^T = [1, 1, 1]^T = \text{column 4 of } H
\]

\textbf{Interpretation}: Syndrome points to error position!

\textbf{Correct}: Flip bit 4 \$\textbackslash rightarrow\$
\(\hat{\mathbf{c}} = [1, 0, 1, 1, 0, 0, 1]\)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Extended Hamming Code}\label{extended-hamming-code}

\textbf{Add 1 overall parity bit}: \((2^m, 2^m - m - 1)\)

\textbf{Example}: Hamming(8,4) - \(d_{\min} = 4\) - Correct 1 error -
Detect 3 errors (SECDED: Single Error Correction, Double Error
Detection)

\textbf{Use case}: ECC RAM

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{BCH Codes}\label{bch-codes}

\textbf{Bose-Chaudhuri-Hocquenghem (BCH)}: Powerful cyclic codes

\textbf{Parameters}: \((n, k, d_{\min})\) over \(\mathrm{GF}(q)\)

\textbf{Key feature}: Can be designed for specific \(d_{\min}\) (error
correction capability)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{BCH Code Properties}\label{bch-code-properties}

\textbf{Binary BCH}: \(q = 2\)

\textbf{Block length}: \(n = 2^m - 1\)

\textbf{Minimum distance}: \(d_{\min} \geq 2t + 1\) (correct \(t\)
errors)

\textbf{Systematic}: First \(k\) bits are data

\textbf{Decoding}: Berlekamp-Massey algorithm,
Peterson-Gorenstein-Zierler

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Common BCH Codes}\label{common-bch-codes}

{\def\LTcaptype{} % do not increment counter
\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
Code & \((n, k)\) & \(t\) & \(d_{\min}\) & Rate \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{BCH(15,11)} & (15, 11) & 1 & 3 & 0.73 \\
\textbf{BCH(15,7)} & (15, 7) & 2 & 5 & 0.47 \\
\textbf{BCH(31,26)} & (31, 26) & 1 & 3 & 0.84 \\
\textbf{BCH(31,21)} & (31, 21) & 2 & 5 & 0.68 \\
\textbf{BCH(31,16)} & (31, 16) & 3 & 7 & 0.52 \\
\textbf{BCH(63,51)} & (63, 51) & 2 & 5 & 0.81 \\
\textbf{BCH(127,106)} & (127, 106) & 3 & 7 & 0.83 \\
\end{longtable}
}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{BCH vs Hamming}\label{bch-vs-hamming}

\textbf{Hamming codes}: Special case of BCH (\(t = 1\))

\textbf{BCH advantage}: Design for any \(t\) (multiple error correction)

\textbf{Example}: BCH(31,16,7) - Corrects \(t = 3\) errors -
Hamming(31,26,3) corrects only \(t = 1\)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Reed-Solomon Codes}\label{reed-solomon-codes}

\textbf{Non-binary BCH codes} over \(\mathrm{GF}(2^m)\) (Galois field)

\textbf{Symbol-based}: Operate on \(m\)-bit symbols (not individual
bits)

\textbf{Parameters}: RS\((n, k)\) over \(\mathrm{GF}(2^m)\) -
\(n = 2^m - 1\) symbols - \(k\) = Data symbols - \(n - k = 2t\) = Parity
symbols (correct \(t\) symbol errors)

\textbf{Key property}: \textbf{Maximum Distance Separable (MDS)}

\[
d_{\min} = n - k + 1
\]

\textbf{Interpretation}: Optimal! Meets Singleton bound.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{RS Code Advantages}\label{rs-code-advantages}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Burst error correction}: One symbol error = up to \(m\) bit
  errors
\item
  \textbf{Optimal distance}: MDS property
\item
  \textbf{Well-understood decoding}: Berlekamp-Massey, Euclidean
  algorithm
\item
  \textbf{Flexible}: Can shorten/puncture for different rates
\end{enumerate}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Common Reed-Solomon
Codes}\label{common-reed-solomon-codes}

{\def\LTcaptype{} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.2653}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.1224}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.1020}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.2041}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.1020}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.2041}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Application
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\(m\)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\((n, k)\)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\(t\)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Overhead
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{CD/DVD} & RS(32,28) & 8 & (255,251) shortened & 2 & 14\% \\
\textbf{QR Code} & RS(255,223) & 8 & (255,223) & 16 & 14\% \\
\textbf{DVB (satellite)} & RS(204,188) & 8 & (255,239) shortened & 8 &
8.5\% \\
\textbf{RAID-6} & RS(n, n-2) & 8 & Variable & 2 & 2 disks \\
\textbf{Voyager} & RS(255,223) & 8 & (255,223) & 16 & 14\% \\
\textbf{DSL (ADSL2+)} & RS(255,239) & 8 & (255,239) & 8 & 6.7\% \\
\end{longtable}
}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Example: QR Code
RS(255,223)}\label{example-qr-code-rs255223}

\textbf{Parameters}: - \(m = 8\) (8-bit symbols = bytes) - \(n = 255\)
bytes - \(k = 223\) bytes (data) - \(2t = 32\) bytes (parity) - Correct
up to \(t = 16\) byte errors

\textbf{Error burst}: If 128 consecutive bits corrupted (16 bytes),
fully correctable!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{RS Encoding}\label{rs-encoding}

\textbf{Polynomial representation}:

\textbf{Data}: \(d_0, d_1, \ldots, d_{k-1}\) (coefficients)

\[
D(x) = d_0 + d_1 x + \cdots + d_{k-1} x^{k-1}
\]

\textbf{Generator polynomial} (degree \(2t\)):

\[
g(x) = \prod_{i=1}^{2t} (x - \alpha^i)
\]

Where \(\alpha\) = Primitive element of \(\mathrm{GF}(2^m)\)

\textbf{Codeword polynomial}: \(C(x) = x^{2t} D(x) + R(x)\)

Where \(R(x) = x^{2t} D(x) \mod g(x)\) (remainder)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{RS Decoding}\label{rs-decoding}

\textbf{Steps}: 1. \textbf{Syndrome calculation}: \(S_i = R(\alpha^i)\)
for \(i = 1, \ldots, 2t\) 2. \textbf{Error locator polynomial}:
Berlekamp-Massey algorithm 3. \textbf{Error positions}: Chien search
(find roots) 4. \textbf{Error values}: Forney algorithm 5.
\textbf{Correction}: Subtract errors from received symbols

\textbf{Complexity}: \(O(t^2)\) or \(O(t \log^2 t)\) with FFT-based
methods

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Cyclic Codes}\label{cyclic-codes}

\textbf{Property}: If \(\mathbf{c} = [c_0, c_1, \ldots, c_{n-1}]\) is a
codeword, so is any cyclic shift:

\[
[c_{n-1}, c_0, c_1, \ldots, c_{n-2}]
\]

\textbf{Advantages}: - Efficient encoding/decoding (shift registers) -
Algebraic structure (polynomials over \(\mathrm{GF}(q)\))

\textbf{Examples}: Hamming codes, BCH codes, Reed-Solomon codes, CRC
codes

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Generator Polynomial}\label{generator-polynomial}

\textbf{Every cyclic code} defined by generator polynomial \(g(x)\)

\textbf{Degree}: \(\deg(g) = n - k\)

\textbf{Property}: \(g(x)\) divides \(x^n - 1\)

\textbf{Encoding}: \(C(x) = D(x) \cdot g(x)\) (non-systematic)

Or systematic: \(C(x) = x^{n-k} D(x) + [x^{n-k} D(x) \mod g(x)]\)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Performance Analysis}\label{performance-analysis}

\subsubsection{Error Correction
Probability}\label{error-correction-probability}

\textbf{For random errors} (BSC with error probability \(p\)):

\textbf{Probability of correct decoding} (code correcting \(t\) errors):

\[
P_{\text{correct}} = \sum_{i=0}^{t} \binom{n}{i} p^i (1-p)^{n-i}
\]

\textbf{Decoding failure} (more than \(t\) errors):

\[
P_{\text{fail}} = 1 - P_{\text{correct}}
\]

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Example: Hamming(7,4)}\label{example-hamming74}

\textbf{Channel}: BSC with \(p = 10^{-3}\)

\textbf{Can correct \(t = 1\) error}:

\[
P_{\text{correct}} = (1-p)^7 + \binom{7}{1} p (1-p)^6 = 0.9997
\]

\textbf{Block error rate}: \(P_{\text{fail}} = 0.0003\)

\textbf{Bit error rate} (after decoding):
\(\approx P_{\text{fail}}/7 = 4.3 \times 10^{-5}\)

\textbf{Improvement}: \(10^{-3} \to 4.3 \times 10^{-5}\)
(23\$\textbackslash times\$ better!)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Concatenated Codes}\label{concatenated-codes}

\textbf{Idea}: Use two codes in series

\textbf{Outer code}: Strong, complex (e.g., Reed-Solomon)

\textbf{Inner code}: Weaker, fast (e.g., convolutional, LDPC)

\textbf{Benefit}: Inner code reduces error rate for outer code

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Example: Voyager Mission}\label{example-voyager-mission}

\textbf{Inner}: Convolutional code (rate 1/2) - Reduces raw BER from
\(5 \times 10^{-3}\) to \(10^{-5}\)

\textbf{Outer}: RS(255,223) - Corrects 16 symbol errors - Final BER:
\textless{} \(10^{-10}\)

\textbf{Total rate}: \(0.5 \times (223/255) = 0.437\) (56\% overhead)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Shortened \& Punctured
Codes}\label{shortened-punctured-codes}

\subsubsection{Shortened Codes}\label{shortened-codes}

\textbf{Remove \(s\) data symbols} (set to 0, don\textquotesingle t
transmit)

\textbf{Example}: RS(255,223) \$\textbackslash rightarrow\$ RS(204,188)
(DVB) - Set first 51 symbols to 0 - Transmit 204 symbols (188 data + 16
parity) - Same \(d_{\min}\), same correction capability

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Punctured Codes}\label{punctured-codes}

\textbf{Delete some parity bits} (increase code rate)

\textbf{Example}: BCH(31,21,5) \$\textbackslash rightarrow\$
BCH(30,21,4) - Remove 1 parity bit - \(d_{\min}\) reduces: 5
\$\textbackslash rightarrow\$ 4 - Correct 2 errors
\$\textbackslash rightarrow\$ 1 error

\textbf{Use case}: Fine-tune code rate for specific channel

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Practical Implementations}\label{practical-implementations}

\subsubsection{1. Memory ECC}\label{memory-ecc}

\textbf{ECC DIMM}: Uses Hamming SECDED (72 bits for 64-bit data)

\textbf{Chipkill}: RS code across multiple chips - Tolerate entire chip
failure (\$\textbackslash times\$8 chip = 8-bit symbol error)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{2. Storage (Hard Drives,
SSDs)}\label{storage-hard-drives-ssds}

\textbf{RAID-6}: Uses RS(n, n-2) - Tolerate 2 disk failures - Example:
10 disks (8 data + 2 parity)

\textbf{SSD error correction}: - BCH codes (10-60 bit correction per 1
KB page) - LDPC (modern SSDs, better performance)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{3. Optical Media}\label{optical-media}

\textbf{CD (Compact Disc)}: - CIRC (Cross-Interleaved Reed-Solomon Code)
- Two RS codes with interleaving - RS(32,28,5) outer, RS(28,24,5) inner
- Tolerates 4000 consecutive error bits (\textasciitilde2.5mm scratch)

\textbf{DVD}: - RS(208,192,17) (correct 8 symbol errors) - Better than
CD

\textbf{Blu-ray}: - RS(216,192,25) or LDPC (more efficient)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{4. QR Codes}\label{qr-codes}

\textbf{Four error correction levels}: - \textbf{Level L}: 7\% recovery
(RS with \(t=2\)) - \textbf{Level M}: 15\% recovery (\(t=5\)) -
\textbf{Level Q}: 25\% recovery (\(t=8\)) - \textbf{Level H}: 30\%
recovery (\(t=11\))

\textbf{Example}: High-res QR code (Version 40) - 2953 bytes data + 688
bytes parity (Level H) - Can recover from 30\% data loss (dirt, damage)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{5. Satellite
Communication}\label{satellite-communication}

\textbf{DVB-S2} (Digital Video Broadcasting): - Outer: BCH(n, k) -
Inner: LDPC (rate 1/4 to 9/10) - Concatenation for robustness

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Python Example: RS(7,3) over
GF(8)}\label{python-example-rs73-over-gf8}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\KeywordTok{class}\NormalTok{ GF8:}
    \CommentTok{"""Galois Field GF(2\^{}3) arithmetic."""}
    \CommentTok{\# Primitive polynomial: x\^{}3 + x + 1}
    \CommentTok{\# Field elements: 0, 1, , \^{}2, ..., \^{}6}
    
\NormalTok{    exp\_table }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{5}\NormalTok{]  }\CommentTok{\# Powers of }
\NormalTok{    log\_table }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]  }\CommentTok{\# Discrete logs}
    
    \AttributeTok{@staticmethod}
    \KeywordTok{def}\NormalTok{ add(a, b):}
        \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{\^{}}\NormalTok{ b  }\CommentTok{\# XOR (addition in GF(2\^{}m))}
    
    \AttributeTok{@staticmethod}
    \KeywordTok{def}\NormalTok{ multiply(a, b):}
        \ControlFlowTok{if}\NormalTok{ a }\OperatorTok{==} \DecValTok{0} \KeywordTok{or}\NormalTok{ b }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
            \ControlFlowTok{return} \DecValTok{0}
\NormalTok{        log\_a }\OperatorTok{=}\NormalTok{ GF8.log\_table[a]}
\NormalTok{        log\_b }\OperatorTok{=}\NormalTok{ GF8.log\_table[b]}
\NormalTok{        log\_prod }\OperatorTok{=}\NormalTok{ (log\_a }\OperatorTok{+}\NormalTok{ log\_b) }\OperatorTok{\%} \DecValTok{7}
        \ControlFlowTok{return}\NormalTok{ GF8.exp\_table[log\_prod]}
    
    \AttributeTok{@staticmethod}
    \KeywordTok{def}\NormalTok{ divide(a, b):}
        \ControlFlowTok{if}\NormalTok{ b }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
            \ControlFlowTok{raise} \PreprocessorTok{ZeroDivisionError}\NormalTok{(}\StringTok{"Division by zero in GF(8)"}\NormalTok{)}
        \ControlFlowTok{if}\NormalTok{ a }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
            \ControlFlowTok{return} \DecValTok{0}
\NormalTok{        log\_a }\OperatorTok{=}\NormalTok{ GF8.log\_table[a]}
\NormalTok{        log\_b }\OperatorTok{=}\NormalTok{ GF8.log\_table[b]}
\NormalTok{        log\_quot }\OperatorTok{=}\NormalTok{ (log\_a }\OperatorTok{{-}}\NormalTok{ log\_b) }\OperatorTok{\%} \DecValTok{7}
        \ControlFlowTok{return}\NormalTok{ GF8.exp\_table[log\_quot]}


\KeywordTok{def}\NormalTok{ rs\_encode\_7\_3():}
    \CommentTok{"""Reed{-}Solomon (7,3) encoding over GF(8)."""}
    \CommentTok{\# Generator polynomial: g(x) = (x{-})(x{-}\^{}2)(x{-}\^{}3)(x{-}\^{}4)}
    \CommentTok{\# For simplicity, use syndrome{-}based encoding}
    
    \CommentTok{\# Example: Encode data [d0, d1, d2]}
\NormalTok{    data }\OperatorTok{=}\NormalTok{ [}\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{]  }\CommentTok{\# 3 symbols from GF(8)}
    
    \CommentTok{\# Compute 4 parity symbols (systematic encoding)}
    \CommentTok{\# c(x) = x\^{}4 * d(x) + [x\^{}4 * d(x) mod g(x)]}
    
    \CommentTok{\# Placeholder: This is simplified (full RS encoding complex)}
\NormalTok{    parity }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{]  }\CommentTok{\# Precomputed for example}
    
\NormalTok{    codeword }\OperatorTok{=}\NormalTok{ data }\OperatorTok{+}\NormalTok{ parity}
    \ControlFlowTok{return}\NormalTok{ codeword}

\CommentTok{\# Example}
\NormalTok{codeword }\OperatorTok{=}\NormalTok{ rs\_encode\_7\_3()}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"RS(7,3) codeword: }\SpecialCharTok{\{}\NormalTok{codeword}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)  }\CommentTok{\# [3, 5, 2, 1, 4, 6, 7]}

\CommentTok{\# Simulate error}
\NormalTok{received }\OperatorTok{=}\NormalTok{ codeword.copy()}
\NormalTok{received[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{0}  \CommentTok{\# Error in position 1}
\NormalTok{received[}\DecValTok{5}\NormalTok{] }\OperatorTok{=} \DecValTok{0}  \CommentTok{\# Error in position 5}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Received (2 errors): }\SpecialCharTok{\{}\NormalTok{received}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Decoding (syndrome calculation, error locator, Forney)}
\CommentTok{\# ... (complex, omitted for brevity)}
\end{Highlighting}
\end{Shaded}

\textbf{Note}: Full RS encoding/decoding requires polynomial operations
over GF-\/-\/-use libraries like \texttt{reedsolo} for production.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Comparison Table}\label{comparison-table}

{\def\LTcaptype{} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2321}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1964}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2143}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1786}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1786}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Code Family
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\(d_{\min}\)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Correction
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Decoding
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Best For
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Hamming} & 3 & 1 bit & Simple (syndrome) & RAM, simple
systems \\
\textbf{Extended Hamming} & 4 & 1 bit, detect 2 & Simple & ECC RAM
(SECDED) \\
\textbf{BCH} & \(2t+1\) & \(t\) bits & BM algorithm & Moderate errors \\
\textbf{Reed-Solomon} & \(n-k+1\) & \(t=(n-k)/2\) symbols & BM + Forney
& Burst errors, storage \\
\textbf{Golay(23,12)} & 7 & 3 bits & Table lookup & Legacy (NASA) \\
\end{longtable}
}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Design Trade-offs}\label{design-trade-offs}

\textbf{Code rate} (R) vs \textbf{Error correction} (\(t\)):

{\def\LTcaptype{} % do not increment counter
\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
Code & Rate & \(t\) (bits) & Overhead & Complexity \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Hamming(7,4) & 0.57 & 1 & 75\% & Very low \\
BCH(31,16) & 0.52 & 3 & 94\% & Moderate \\
RS(255,223) & 0.875 & 16 symbols & 14\% & Moderate \\
Golay(23,12) & 0.52 & 3 & 92\% & Low \\
\end{longtable}
}

\textbf{General rule}: Stronger correction \$\textbackslash rightarrow\$
More overhead \$\textbackslash rightarrow\$ Lower rate

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Related Topics}\label{related-topics}

\begin{itemize}
\tightlist
\item
  \textbf{{[}{[}Hamming-Distance-\&-Error-Detection{]}{]}}: Foundation
  for block codes
\item
  \textbf{{[}{[}Convolutional-Codes-\&-Viterbi-Decoding{]}{]}}:
  Sequential codes
\item
  \textbf{{[}{[}LDPC-Codes{]}{]}}: Modern capacity-approaching codes
\item
  \textbf{{[}{[}Forward-Error-Correction-(FEC){]}{]}}: General FEC
  principles
\item
  \textbf{{[}{[}Bit-Error-Rate-(BER){]}{]}}: Performance metric
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Key takeaway}: \textbf{Block codes encode \(k\) data symbols
into \(n\) code symbols.} Linear block codes use generator matrix \(G\)
for encoding, parity-check matrix \(H\) for syndrome decoding.
\textbf{Hamming codes}: \((2^m-1, 2^m-m-1, 3)\) correct 1 bit error,
perfect codes. \textbf{BCH codes}: Cyclic codes designed for specific
\(t\)-error correction (Berlekamp-Massey decoding). \textbf{Reed-Solomon
codes}: Non-binary (\(\mathrm{GF}(2^m)\)), MDS property
(\(d_{\min} = n-k+1\)), optimal for burst errors. RS used in CDs, DVDs,
QR codes, RAID, satellite. Concatenated codes (inner + outer) achieve
very low BER (e.g., Voyager \textless{} \(10^{-10}\)). Trade-off: Higher
correction capability requires more parity (lower rate).

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\emph{This wiki is part of the {[}{[}Home\textbar Chimera Project{]}{]}
documentation.}
