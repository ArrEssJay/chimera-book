\section{Adaptive Modulation \& Coding
(AMC)}\label{adaptive-modulation-coding-amc}

\textbf{Adaptive Modulation and Coding (AMC)} dynamically adjusts
transmission parameters (modulation order, code rate, bandwidth) based
on real-time channel conditions to maximize throughput while maintaining
target error rates. AMC is fundamental to modern wireless standards
(LTE, 5G NR, WiFi 6/7) and enables systems to track
{[}{[}Shannon\textquotesingle s-Channel-Capacity-Theorem\textbar Shannon
capacity{]}{]} in time-varying channels.

\textbf{Core principle}: Match data rate to instantaneous channel
quality-\/-\/-use aggressive modulation when channel is good, fall back
to robust modulation when channel degrades.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ The AMC
Concept}{ The AMC Concept}}\label{the-amc-concept}

\subsubsection{Without AMC (Fixed
Modulation)}\label{without-amc-fixed-modulation}

\begin{verbatim}
Fixed 64-QAM, Rate-1/2 FEC:
 Data rate: Constant (e.g., 50 Mbps)
 High SNR: Wasted capacity (could use 256-QAM)
 Low SNR: High BER, retransmissions, failures

Result: Suboptimal throughput, especially in fading channels
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{With AMC}\label{with-amc}

\begin{verbatim}
Adapt modulation + coding to channel:

Good channel (SNR = 30 dB):
 256-QAM, Rate-5/6  100 Mbps, BER = 10 

Moderate channel (SNR = 20 dB):
 64-QAM, Rate-3/4  60 Mbps, BER = 10 

Poor channel (SNR = 10 dB):
 QPSK, Rate-1/2  10 Mbps, BER = 10 

Faded channel (SNR = 5 dB):
 BPSK, Rate-1/3  3 Mbps, BER = 10 

Result: Maximize throughput while maintaining quality
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ Link Adaptation
Framework}{ Link Adaptation Framework}}\label{link-adaptation-framework}

\subsubsection{Channel State Information
(CSI)}\label{channel-state-information-csi}

\textbf{CSI acquisition}:

\begin{verbatim}
Downlink (BS  UE):
1. BS transmits pilot/reference signals
2. UE measures channel (amplitude, phase per subcarrier)
3. UE reports CSI feedback to BS
4. BS selects MCS (Modulation and Coding Scheme)

Uplink (UE  BS):
1. UE transmits sounding reference signal (SRS)
2. BS measures channel directly
3. BS selects MCS (no feedback needed if TDD reciprocity)
\end{verbatim}

\textbf{CSI feedback types}:

\begin{verbatim}
Full CSI:
- H matrix (nT × nR complex gains per subcarrier)
- High overhead (bits  nT × nR × N_subcarriers)
- Used: Massive MIMO (TDD reciprocity  no feedback)

Quantized CSI:
- Codebook-based: Index to predefined precoding matrices
- CQI (Channel Quality Indicator): Scalar metric
- Low overhead
- Used: LTE, 5G NR FDD
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Channel Quality Indicator
(CQI)}\label{channel-quality-indicator-cqi}

\textbf{CQI definition}:

\begin{verbatim}
CQI = f(SINR, interference, fading statistics)

Mapping:
CQI  (Modulation, Code Rate)  Spectral Efficiency

Example (LTE):
CQI 1:  QPSK, Rate-1/8   0.15 bits/s/Hz (SINR < 0 dB)
CQI 5:  QPSK, Rate-1/2   1.0 bits/s/Hz (SINR  5 dB)
CQI 10: 64-QAM, Rate-3/4  4.5 bits/s/Hz (SINR  20 dB)
CQI 15: 256-QAM, Rate-7/8  7.0 bits/s/Hz (SINR  30 dB)

Target: <10% BLER (Block Error Rate) after first transmission
\end{verbatim}

\textbf{CQI calculation}:

\begin{verbatim}
Instantaneous SINR per subcarrier:
SINR = |H|² · P / (N + I)

where:
- H = channel gain on subcarrier k
- P = transmit power
- N = noise power
- I = interference power

Effective SINR (over all subcarriers):
SINR_eff = f(SINR, SINR, ..., SINR_N)

Methods:
1. Mean SINR: SINR_eff = mean(SINR)
2. EESM (Exponential Effective SINR Mapping):
   SINR_eff = -·ln(mean(exp(-SINR/)))
3. MIESM (Mutual Information ESM):
   SINR_eff based on mutual information

CQI = Quantize(SINR_eff)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Modulation and Coding Schemes
(MCS)}\label{modulation-and-coding-schemes-mcs}

\textbf{MCS Table (LTE example)}:

{\def\LTcaptype{} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1358}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1481}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1358}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2469}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
MCS Index
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Modulation
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Code Rate
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Spectral Eff. (bits/s/Hz)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Required SINR (dB)
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & QPSK & 0.076 & 0.15 & -6 \\
5 & QPSK & 0.439 & 0.88 & 2 \\
10 & 16-QAM & 0.478 & 1.91 & 10 \\
15 & 64-QAM & 0.553 & 3.32 & 18 \\
20 & 64-QAM & 0.750 & 4.50 & 24 \\
28 & 256-QAM & 0.926 & 7.41 & 32 \\
\end{longtable}
}

\textbf{Selection algorithm}:

\begin{verbatim}
Given CQI (estimated SINR):
1. Find highest MCS where SINR  Required_SINR
2. Verify: Predicted_BLER < 10%
3. Transmit with selected MCS

If BLER > 10% (ACK/NACK feedback):
 Fall back to lower MCS (more robust)

If BLER < 1% (excellent channel):
 Attempt higher MCS (increase throughput)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ Hybrid ARQ
(HARQ)}{ Hybrid ARQ (HARQ)}}\label{hybrid-arq-harq}

\textbf{Automatic Repeat Request} with \textbf{Forward Error
Correction}-\/-\/-retransmissions carry additional redundancy.

\subsubsection{HARQ Types}\label{harq-types}

\textbf{Type I - Chase Combining}:

\begin{verbatim}
First transmission: Original codeword
Retransmission(s): Same codeword (identical)

Receiver: Combine multiple copies (soft combining)
 Effective SNR increases with each retransmission

Example:
- TX 1: SNR = 5 dB  NACK (failed)
- TX 2: SNR = 5 dB  Combined SNR = 8 dB  ACK 

Advantage: Simple
Disadvantage: No incremental redundancy
\end{verbatim}

\textbf{Type II/III - Incremental Redundancy (IR)}:

\begin{verbatim}
First transmission: High code rate (less redundancy)
Retransmission 1: Additional parity bits (lower effective rate)
Retransmission 2: Even more parity (lowest rate)

Example (Rate-compatible punctured code):
- TX 1: Rate-3/4 (fast, fragile)  NACK
- TX 2: Rate-2/3 (add parity)  Combined rate-1/2  NACK
- TX 3: Rate-1/2 (add more parity)  Combined rate-1/3  ACK 

Advantage: Adaptive coding without re-encoding
Disadvantage: More complex receiver (soft buffer management)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{HARQ in LTE/5G}\label{harq-in-lte5g}

\textbf{LTE HARQ process}:

\begin{verbatim}
8 parallel HARQ processes (downlink), 8 (uplink)
RTT (Round-Trip Time): 8 ms
Max retransmissions: 4 (configurable)

Timeline:
t = 0 ms:    TX initial transmission (Process 0)
t = 4 ms:    RX decodes, sends ACK/NACK
t = 8 ms:    If NACK, retransmit (Process 0)
             Meanwhile, Process 1-7 active (pipelined)

Result: 8 simultaneous processes  continuous transmission
\end{verbatim}

\textbf{5G NR HARQ}:

\begin{verbatim}
16+ parallel HARQ processes (flexible)
RTT: 2-8 ms (depends on numerology)
Adaptive retransmission:
- Same MCS (Chase combining)
- Different MCS (adapt to channel change)
- Different RV (Redundancy Version) for IR
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ AMC Performance
Analysis}{ AMC Performance Analysis}}\label{amc-performance-analysis}

\subsubsection{Shannon-Capacity
Tracking}\label{shannon-capacity-tracking}

\textbf{Ideal AMC} approaches Shannon capacity:

\begin{verbatim}
C(SNR) = B · log(1 + SNR)

Without AMC (fixed QPSK, rate-1/2):
R_fixed = B · 1 bits/s/Hz (for all SNR)
Efficiency: R_fixed / C(SNR) = low at high SNR

With AMC:
R_AMC(SNR)  C(SNR) - 

where  = implementation gap (typically 2-5 dB from Shannon)

Throughput gain: 3-5× in typical fading scenarios
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Throughput in Fading
Channels}\label{throughput-in-fading-channels}

\textbf{Rayleigh fading channel} (urban/indoor):

\begin{verbatim}
Instantaneous SNR:  (exponentially distributed)
Average SNR: 

Outage probability:
P_out(R) = P(C() < R) = 1 - exp(-R / ( · B))

Without AMC (fixed rate R):
- Outage when  < _threshold  complete failure
- Average throughput: R · (1 - P_out)

With AMC:
- Adapt R = C() continuously
- No outage (always some rate achievable)
- Average throughput: E[C()] = ^ C() · p() d

Ergodic capacity:
C_ergodic = B · E[log(1 + )]

For Rayleigh: C_ergodic  B · log(e · ) (high SNR)
\end{verbatim}

\textbf{Numerical example}:

\begin{verbatim}
Channel: Rayleigh fading,  = 20 dB, B = 20 MHz

Fixed 64-QAM (rate-3/4):
- Required SNR: 18 dB
- Outage: P( < 18 dB) = 37%
- Average throughput: 4.5 × 20 MHz × 0.63 = 57 Mbps

AMC (QPSK to 256-QAM):
- Always adapts to channel
- Average throughput:  100 Mbps

Gain: 1.75× throughput improvement
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ AMC in
Standards}{ AMC in Standards}}\label{amc-in-standards}

\subsubsection{LTE Adaptive Modulation}\label{lte-adaptive-modulation}

\textbf{Downlink (eNodeB \$\textbackslash rightarrow\$ UE)}:

\begin{verbatim}
CQI reporting:
- Periodicity: 5-10 ms (semi-static)
- Wideband or subband (per RB - Resource Block)
- UE measures RSRP, RSRQ, SINR  computes CQI

MCS selection:
- eNodeB scheduler receives CQI
- Selects MCS per UE per RB
- Goals: Maximize cell throughput, maintain fairness

Resource allocation:
- Time-frequency (OFDMA)
- 1 RB = 12 subcarriers × 1 slot (0.5 ms)
- Assign high MCS to users with good CQI
\end{verbatim}

\textbf{Uplink (UE \$\textbackslash rightarrow\$ eNodeB)}:

\begin{verbatim}
UE transmits SRS (Sounding Reference Signal)
eNodeB measures channel directly (TDD reciprocity helps)
eNodeB commands MCS via PDCCH (Physical Downlink Control Channel)

Uplink challenges:
- Limited UE power  coverage-limited
- Lower MCS typical (vs. downlink)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{5G NR Ultra-Lean Design}\label{g-nr-ultra-lean-design}

\textbf{Dynamic adaptation}:

\begin{verbatim}
Ultra-flexible frame structure:
- Slot duration: 0.125-1 ms (depends on numerology)
- Mini-slots: <1 ms (ultra-low latency)
- HARQ feedback: 2-4 slots (faster than LTE)

Beam management:
- Massive MIMO: Beamformed transmissions
- CSI-RS: Beam-specific channel measurement
- Adapt MCS per beam (spatial dimension)

Grant-free transmission (URLLC):
- Pre-configured MCS (no dynamic CQI)
- Used for ultra-reliable, low-latency (factory automation)
\end{verbatim}

\textbf{Massive MIMO adaptation}:

\begin{verbatim}
Per-user MCS:
- User 1 (cell center, high SINR): 256-QAM, rate-5/6
- User 2 (cell edge, low SINR): QPSK, rate-1/3
- Simultaneous (MU-MIMO) on same resource blocks

Spectral efficiency:
Sum rate = _{i} R_i (bits/s/Hz per user)
         = 7 + 1 = 8 bits/s/Hz (vs. 4 for single-user)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{WiFi 6/7 (802.11ax/be)}\label{wifi-67-802.11axbe}

\textbf{Rate adaptation}:

\begin{verbatim}
WiFi metrics:
- RSSI (Received Signal Strength Indicator)
- PER (Packet Error Rate)
- Retry count

MCS selection:
- Minstrel / SampleRate algorithms (open-source)
- Proprietary vendor algorithms (Cisco, Qualcomm)
- Test higher MCS occasionally (probing)

Spatial stream adaptation:
- 1 stream: Long range, reliable
- 4 streams: Short range, high throughput
- Adapt based on distance, interference

Example (WiFi 6, 80 MHz):
- Close (1 m): 4 streams, 1024-QAM, rate-5/6  1.2 Gbps
- Medium (10 m): 2 streams, 256-QAM, rate-3/4  600 Mbps
- Far (50 m): 1 stream, QPSK, rate-1/2  30 Mbps
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ Advanced AMC
Techniques}{ Advanced AMC Techniques}}\label{advanced-amc-techniques}

\subsubsection{Outer-Loop Link Adaptation
(OLLA)}\label{outer-loop-link-adaptation-olla}

\textbf{Motivation}: CQI can be inaccurate (channel estimation errors,
feedback delay).

\textbf{OLLA principle}:

\begin{verbatim}
Adjust MCS based on ACK/NACK history, not just CQI.

Algorithm:
1. Start with MCS based on CQI
2. If NACK: Decrease MCS (_down = 1 dB)
3. If ACK: Increase MCS (_up = 0.01 dB)

Asymmetric adjustment:
- Fast decrease (avoid errors)
- Slow increase (test cautiously)

Result: Converges to optimal MCS despite CQI errors
\end{verbatim}

\textbf{Implementation}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ olla\_adaptation(cqi, ack\_history, target\_bler}\OperatorTok{=}\FloatTok{0.1}\NormalTok{):}
    \CommentTok{"""}
\CommentTok{    Outer{-}loop link adaptation.}
\CommentTok{    }
\CommentTok{    Args:}
\CommentTok{        cqi: Reported channel quality indicator}
\CommentTok{        ack\_history: Recent ACK/NACK outcomes}
\CommentTok{        target\_bler: Target block error rate}
\CommentTok{    }
\CommentTok{    Returns:}
\CommentTok{        Adjusted MCS index}
\CommentTok{    """}
\NormalTok{    mcs\_base }\OperatorTok{=}\NormalTok{ cqi\_to\_mcs(cqi)}
    
    \CommentTok{\# Compute recent BLER}
\NormalTok{    recent\_bler }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ np.mean(ack\_history)}
    
    \CommentTok{\# Offset adjustment}
    \ControlFlowTok{if}\NormalTok{ recent\_bler }\OperatorTok{\textgreater{}}\NormalTok{ target\_bler:}
\NormalTok{        offset\_db }\OperatorTok{=} \OperatorTok{{-}}\FloatTok{1.0}  \CommentTok{\# More conservative}
    \ControlFlowTok{elif}\NormalTok{ recent\_bler }\OperatorTok{\textless{}}\NormalTok{ target\_bler }\OperatorTok{/} \DecValTok{2}\NormalTok{:}
\NormalTok{        offset\_db }\OperatorTok{=} \OperatorTok{+}\FloatTok{0.5}  \CommentTok{\# More aggressive}
    \ControlFlowTok{else}\NormalTok{:}
\NormalTok{        offset\_db }\OperatorTok{=} \FloatTok{0.0}  \CommentTok{\# Stay}
    
    \CommentTok{\# Adjust MCS}
\NormalTok{    mcs\_adjusted }\OperatorTok{=}\NormalTok{ mcs\_base }\OperatorTok{+} \BuiltInTok{int}\NormalTok{(offset\_db }\OperatorTok{/} \DecValTok{2}\NormalTok{)  }\CommentTok{\# \textasciitilde{}2 dB per MCS}
\NormalTok{    mcs\_adjusted }\OperatorTok{=}\NormalTok{ np.clip(mcs\_adjusted, }\DecValTok{0}\NormalTok{, }\DecValTok{28}\NormalTok{)}
    
    \ControlFlowTok{return}\NormalTok{ mcs\_adjusted}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Cross-Layer Optimization}\label{cross-layer-optimization}

\textbf{Joint optimization} of PHY (MCS) and MAC (scheduling):

\textbf{Proportional Fair Scheduler}:

\begin{verbatim}
Maximize: _{i} log(R_i)  (sum log throughput)

User priority:
Priority_i = R_instantaneous_i / R_average_i

where:
- R_instantaneous: Rate achievable now (AMC-selected MCS)
- R_average: Long-term average throughput

Result:
- User with good channel gets high MCS  high R_instantaneous
- If already has high R_average, priority decreases
- Balances throughput and fairness
\end{verbatim}

\textbf{Buffer-aware AMC}:

\begin{verbatim}
If buffer almost empty:
 Use lower MCS (reliable, avoid stalls)

If buffer full:
 Use higher MCS (aggressive, drain buffer)

Delay-sensitive (VoIP):
 Conservative MCS (avoid retransmissions)

Throughput-oriented (file download):
 Aggressive MCS (maximize rate, tolerate retries)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Predictive AMC}\label{predictive-amc}

\textbf{Anticipate channel changes} before they occur.

\textbf{Method 1 - Doppler-based prediction}:

\begin{verbatim}
High mobility (vehicular):
- Channel changes rapidly (coherence time ~10 ms)
- CQI feedback outdated by RTT (8 ms)

Prediction:
1. Estimate Doppler shift (f_D = v/)
2. Predict channel evolution: H(t + t) = f(H(t), f_D)
3. Select MCS for predicted channel

Autoregressive model:
H[n+1] = a·H[n] + a·H[n-1] + ... + noise

Wiener filter / Kalman filter for prediction
\end{verbatim}

\textbf{Method 2 - Machine learning}:

\begin{verbatim}
Train neural network:
- Input: [H[n], H[n-1], ..., H[n-k], velocity, location]
- Output: H[n+1] (predicted channel)

Online learning:
- Update weights based on prediction error
- Adapt to user-specific channel patterns

Benefit: 2-3 dB gain in high-mobility scenarios
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ Python Implementation
Example}{ Python Implementation Example}}\label{python-implementation-example}

\subsubsection{AMC Simulator}\label{amc-simulator}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\KeywordTok{def}\NormalTok{ generate\_fading\_channel(n\_samples, coherence\_time}\OperatorTok{=}\DecValTok{100}\NormalTok{):}
    \CommentTok{"""}
\CommentTok{    Generate Rayleigh fading channel (Clarke\textquotesingle{}s model).}
\CommentTok{    }
\CommentTok{    Args:}
\CommentTok{        n\_samples: Number of time samples}
\CommentTok{        coherence\_time: Channel coherence (samples)}
\CommentTok{    }
\CommentTok{    Returns:}
\CommentTok{        Channel gains (linear)}
\CommentTok{    """}
    \CommentTok{\# Generate complex Gaussian samples}
\NormalTok{    h\_i }\OperatorTok{=}\NormalTok{ np.random.randn(n\_samples)}
\NormalTok{    h\_q }\OperatorTok{=}\NormalTok{ np.random.randn(n\_samples)}
\NormalTok{    h }\OperatorTok{=}\NormalTok{ (h\_i }\OperatorTok{+} \OtherTok{1j}\OperatorTok{*}\NormalTok{h\_q) }\OperatorTok{/}\NormalTok{ np.sqrt(}\DecValTok{2}\NormalTok{)}
    
    \CommentTok{\# Low{-}pass filter (coherence time)}
    \ImportTok{from}\NormalTok{ scipy.signal }\ImportTok{import}\NormalTok{ butter, lfilter}
\NormalTok{    b, a }\OperatorTok{=}\NormalTok{ butter(}\DecValTok{3}\NormalTok{, }\DecValTok{1}\OperatorTok{/}\NormalTok{coherence\_time)}
\NormalTok{    h }\OperatorTok{=}\NormalTok{ lfilter(b, a, h)}
    
    \CommentTok{\# Normalize to unit average power}
\NormalTok{    h }\OperatorTok{/=}\NormalTok{ np.sqrt(np.mean(np.}\BuiltInTok{abs}\NormalTok{(h)}\OperatorTok{**}\DecValTok{2}\NormalTok{))}
    
    \ControlFlowTok{return}\NormalTok{ h}

\KeywordTok{def}\NormalTok{ snr\_to\_cqi(snr\_db):}
    \CommentTok{"""}
\CommentTok{    Map SNR to CQI index (0{-}15).}
\CommentTok{    """}
\NormalTok{    cqi\_table }\OperatorTok{=}\NormalTok{ [}
\NormalTok{        (}\OperatorTok{{-}}\DecValTok{6}\NormalTok{, }\DecValTok{0}\NormalTok{), (}\DecValTok{0}\NormalTok{, }\DecValTok{5}\NormalTok{), (}\DecValTok{5}\NormalTok{, }\DecValTok{8}\NormalTok{), (}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{), }
\NormalTok{        (}\DecValTok{15}\NormalTok{, }\DecValTok{13}\NormalTok{), (}\DecValTok{20}\NormalTok{, }\DecValTok{15}\NormalTok{), (}\DecValTok{25}\NormalTok{, }\DecValTok{15}\NormalTok{)}
\NormalTok{    ]}
    \ControlFlowTok{for}\NormalTok{ snr\_thresh, cqi }\KeywordTok{in}\NormalTok{ cqi\_table:}
        \ControlFlowTok{if}\NormalTok{ snr\_db }\OperatorTok{\textless{}}\NormalTok{ snr\_thresh:}
            \ControlFlowTok{return} \BuiltInTok{max}\NormalTok{(}\DecValTok{0}\NormalTok{, cqi }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}
    \ControlFlowTok{return} \DecValTok{15}

\KeywordTok{def}\NormalTok{ cqi\_to\_mcs(cqi):}
    \CommentTok{"""}
\CommentTok{    Map CQI to MCS parameters.}
\CommentTok{    }
\CommentTok{    Returns:}
\CommentTok{        (modulation\_order, code\_rate, spectral\_efficiency)}
\CommentTok{    """}
\NormalTok{    mcs\_table }\OperatorTok{=}\NormalTok{ [}
\NormalTok{        (}\DecValTok{2}\NormalTok{, }\FloatTok{0.08}\NormalTok{, }\FloatTok{0.15}\NormalTok{),   }\CommentTok{\# CQI 0{-}1: QPSK}
\NormalTok{        (}\DecValTok{2}\NormalTok{, }\FloatTok{0.44}\NormalTok{, }\FloatTok{0.88}\NormalTok{),   }\CommentTok{\# CQI 5: QPSK}
\NormalTok{        (}\DecValTok{4}\NormalTok{, }\FloatTok{0.48}\NormalTok{, }\FloatTok{1.91}\NormalTok{),   }\CommentTok{\# CQI 10: 16{-}QAM}
\NormalTok{        (}\DecValTok{6}\NormalTok{, }\FloatTok{0.55}\NormalTok{, }\FloatTok{3.32}\NormalTok{),   }\CommentTok{\# CQI 15: 64{-}QAM}
\NormalTok{        (}\DecValTok{8}\NormalTok{, }\FloatTok{0.93}\NormalTok{, }\FloatTok{7.41}\NormalTok{),   }\CommentTok{\# CQI 15+: 256{-}QAM}
\NormalTok{    ]}
\NormalTok{    idx }\OperatorTok{=} \BuiltInTok{min}\NormalTok{(cqi }\OperatorTok{//} \DecValTok{4}\NormalTok{, }\BuiltInTok{len}\NormalTok{(mcs\_table) }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}
    \ControlFlowTok{return}\NormalTok{ mcs\_table[idx]}

\KeywordTok{def}\NormalTok{ compute\_bler(snr\_db, mcs\_params):}
    \CommentTok{"""}
\CommentTok{    Compute Block Error Rate for given SNR and MCS.}
\CommentTok{    }
\CommentTok{    Uses Shannon bound approximation.}
\CommentTok{    """}
\NormalTok{    mod\_order, code\_rate, spec\_eff }\OperatorTok{=}\NormalTok{ mcs\_params}
    
    \CommentTok{\# Required SNR for target BER = 10\^{}{-}6}
\NormalTok{    required\_snr }\OperatorTok{=}\NormalTok{ \{}
        \DecValTok{2}\NormalTok{: }\FloatTok{9.6}\NormalTok{,   }\CommentTok{\# QPSK}
        \DecValTok{4}\NormalTok{: }\FloatTok{16.5}\NormalTok{,  }\CommentTok{\# 16{-}QAM}
        \DecValTok{6}\NormalTok{: }\FloatTok{22.0}\NormalTok{,  }\CommentTok{\# 64{-}QAM}
        \DecValTok{8}\NormalTok{: }\FloatTok{28.0}\NormalTok{,  }\CommentTok{\# 256{-}QAM}
\NormalTok{    \}[mod\_order]}
    
    \CommentTok{\# Adjust for code rate}
\NormalTok{    required\_snr }\OperatorTok{{-}=} \DecValTok{10} \OperatorTok{*}\NormalTok{ np.log10(code\_rate)}
    
    \CommentTok{\# BLER approximation (exponential model)}
    \ControlFlowTok{if}\NormalTok{ snr\_db }\OperatorTok{\textgreater{}}\NormalTok{ required\_snr:}
\NormalTok{        bler }\OperatorTok{=}\NormalTok{ np.exp(}\OperatorTok{{-}}\FloatTok{0.5} \OperatorTok{*}\NormalTok{ (snr\_db }\OperatorTok{{-}}\NormalTok{ required\_snr))}
    \ControlFlowTok{else}\NormalTok{:}
\NormalTok{        bler }\OperatorTok{=} \FloatTok{0.5}  \CommentTok{\# High error rate}
    
    \ControlFlowTok{return} \BuiltInTok{min}\NormalTok{(bler, }\FloatTok{0.5}\NormalTok{)}

\CommentTok{\# Simulation}
\NormalTok{n\_samples }\OperatorTok{=} \DecValTok{10000}
\NormalTok{avg\_snr\_db }\OperatorTok{=} \DecValTok{20}
\NormalTok{coherence\_time }\OperatorTok{=} \DecValTok{100}

\CommentTok{\# Generate fading channel}
\NormalTok{h }\OperatorTok{=}\NormalTok{ generate\_fading\_channel(n\_samples, coherence\_time)}
\NormalTok{snr\_inst }\OperatorTok{=}\NormalTok{ avg\_snr\_db }\OperatorTok{+} \DecValTok{20}\OperatorTok{*}\NormalTok{np.log10(np.}\BuiltInTok{abs}\NormalTok{(h))  }\CommentTok{\# Instantaneous SNR}

\CommentTok{\# AMC simulation}
\NormalTok{throughput\_amc }\OperatorTok{=}\NormalTok{ []}
\NormalTok{throughput\_fixed }\OperatorTok{=}\NormalTok{ []}
\NormalTok{bler\_amc }\OperatorTok{=}\NormalTok{ []}

\CommentTok{\# Fixed MCS (64{-}QAM, rate{-}3/4)}
\NormalTok{fixed\_mcs }\OperatorTok{=}\NormalTok{ (}\DecValTok{6}\NormalTok{, }\FloatTok{0.75}\NormalTok{, }\FloatTok{4.5}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ snr\_db }\KeywordTok{in}\NormalTok{ snr\_inst:}
    \CommentTok{\# AMC: Select MCS based on CQI}
\NormalTok{    cqi }\OperatorTok{=}\NormalTok{ snr\_to\_cqi(snr\_db)}
\NormalTok{    mcs }\OperatorTok{=}\NormalTok{ cqi\_to\_mcs(cqi)}
    
    \CommentTok{\# Compute BLER}
\NormalTok{    bler }\OperatorTok{=}\NormalTok{ compute\_bler(snr\_db, mcs)}
    
    \CommentTok{\# Throughput (accounting for retransmissions)}
\NormalTok{    tput\_amc }\OperatorTok{=}\NormalTok{ mcs[}\DecValTok{2}\NormalTok{] }\OperatorTok{*}\NormalTok{ (}\DecValTok{1} \OperatorTok{{-}}\NormalTok{ bler)  }\CommentTok{\# bits/s/Hz}
\NormalTok{    tput\_fixed }\OperatorTok{=}\NormalTok{ fixed\_mcs[}\DecValTok{2}\NormalTok{] }\OperatorTok{*}\NormalTok{ (}\DecValTok{1} \OperatorTok{{-}}\NormalTok{ compute\_bler(snr\_db, fixed\_mcs))}
    
\NormalTok{    throughput\_amc.append(tput\_amc)}
\NormalTok{    throughput\_fixed.append(tput\_fixed)}
\NormalTok{    bler\_amc.append(bler)}

\CommentTok{\# Results}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Average SNR: }\SpecialCharTok{\{}\NormalTok{avg\_snr\_db}\SpecialCharTok{\}}\SpecialStringTok{ dB"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"AMC average throughput: }\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{mean(throughput\_amc)}\SpecialCharTok{:.2f\}}\SpecialStringTok{ bits/s/Hz"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Fixed MCS throughput: }\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{mean(throughput\_fixed)}\SpecialCharTok{:.2f\}}\SpecialStringTok{ bits/s/Hz"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"AMC gain: }\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{mean(throughput\_amc) }\OperatorTok{/}\NormalTok{ np}\SpecialCharTok{.}\NormalTok{mean(throughput\_fixed)}\SpecialCharTok{:.2f\}}\SpecialStringTok{×"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"AMC average BLER: }\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{mean(bler\_amc)}\SpecialCharTok{:.2\%\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ When to Use
AMC}{ When to Use AMC}}\label{when-to-use-amc}

\subsubsection{AMC Excels:}\label{amc-excels}

\textbf{Time-varying channels} (mobility, fading)\\
\textbf{Wide SNR range} (cell-edge to cell-center users)\\
\textbf{Throughput-oriented} applications (web, video streaming)\\
\textbf{Multi-user systems} (fairness via per-user adaptation)\\
\textbf{OFDM systems} (per-subcarrier or per-RB adaptation)

\subsubsection{AMC Challenges:}\label{amc-challenges}

\textbf{Fast fading} (feedback delay \textgreater{} coherence time)\\
\textbf{Feedback overhead} (high for wideband, MIMO)\\
\textbf{Latency-sensitive} (delay from MCS switching)\\
\textbf{Low SNR regime} (limited MCS choices)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ Further
Reading}{ Further Reading}}\label{further-reading}

\subsubsection{Textbooks}\label{textbooks}

\begin{itemize}
\tightlist
\item
  \textbf{Goldsmith}, \emph{Wireless Communications} (Chapter 9:
  Adaptive Modulation) - Comprehensive treatment
\item
  \textbf{Tse \& Viswanath}, \emph{Fundamentals of Wireless
  Communication} (Chapter 5: Capacity of fading channels)
\item
  \textbf{Hanzo et al.}, \emph{Adaptive Wireless Transceivers} - Deep
  dive into AMC algorithms
\end{itemize}

\subsubsection{Key Papers}\label{key-papers}

\begin{itemize}
\tightlist
\item
  \textbf{Goldsmith \& Varaiya} (1997): ``Capacity of fading channels
  with CSI'' - Foundational theory
\item
  \textbf{Caire et al.} (1999): ``Optimum power control over fading
  channels'' - Water-filling for fading
\item
  \textbf{Ekström et al.} (2006): ``Technical Solutions for 3G LTE'' -
  Practical LTE AMC
\end{itemize}

\subsubsection{Standards Documents}\label{standards-documents}

\begin{itemize}
\tightlist
\item
  \textbf{3GPP TS 36.213}: LTE Physical Layer Procedures (CQI, MCS
  tables)
\item
  \textbf{3GPP TS 38.214}: 5G NR Physical Layer (AMC, HARQ)
\item
  \textbf{IEEE 802.11ax}: WiFi 6 (rate adaptation algorithms)
\end{itemize}

\subsubsection{Related Topics}\label{related-topics}

\begin{itemize}
\tightlist
\item
  {[}{[}Shannon\textquotesingle s-Channel-Capacity-Theorem{]}{]} -
  Theoretical foundation for AMC
\item
  {[}{[}OFDM-\&-Multicarrier-Modulation{]}{]} - Per-subcarrier
  adaptation
\item
  {[}{[}MIMO-\&-Spatial-Multiplexing{]}{]} - Per-stream MCS adaptation
\item
  {[}{[}Forward-Error-Correction-(FEC){]}{]} - Code rate adaptation
\item
  {[}{[}Real-World-System-Examples{]}{]} - LTE, 5G, WiFi implementations
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Summary}: Adaptive Modulation and Coding (AMC) is the bridge
between
{[}{[}Shannon\textquotesingle s-Channel-Capacity-Theorem\textbar Shannon
theory{]}{]} and practical wireless systems. By dynamically selecting
modulation order (BPSK \$\textbackslash rightarrow\$ 256-QAM) and code
rate (1/3 \$\textbackslash rightarrow\$ 7/8) based on Channel Quality
Indicator (CQI) feedback, AMC systems track instantaneous channel
capacity and maximize throughput while maintaining target error rates
(typically \textless10\% BLER). LTE/5G use CQI reporting (1-15) mapped
to MCS tables, combined with HARQ for robustness. AMC provides
2-5\$\textbackslash times\$ throughput gain in fading channels compared
to fixed modulation. Outer-loop link adaptation (OLLA) corrects for CQI
errors. Cross-layer optimization integrates AMC with scheduling
(proportional fair) and buffer management. Predictive AMC uses Doppler
estimation or machine learning to anticipate channel changes. AMC is
essential for spectral efficiency in modern cellular and WiFi networks,
enabling gigabit-per-second data rates while serving users across wide
SNR ranges (cell-edge to cell-center).
