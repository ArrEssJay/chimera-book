% ==============================================================================
% CHAPTER 32: Block Codes (Hamming, BCH, Reed-Solomon)
% ==============================================================================

\chapter{Block Codes: Hamming, BCH \& Reed-Solomon}
\label{ch:block-codes}

\begin{nontechnical}
    \textbf{Block codes are like adding sudoku-style clues to your data.} They take a chunk of your information, perform some clever maths on it to generate a set of "parity" bits, and append them. If some of the bits get corrupted during transmission, the receiver can re-do the maths and use the clues to figure out exactly what went wrong and fix it.

    \parhead{The three most famous types}
    \begin{itemize}
        \item \textbf{Hamming Codes:} The original, brilliant error-correcting code invented in 1950. It's incredibly efficient at fixing single-bit errors and is the reason ECC RAM in servers doesn't crash from random cosmic ray bit-flips.
        \item \textbf{BCH Codes:} A powerful generalisation of Hamming codes that can be designed to fix any number of errors, not just one.
        \item \textbf{Reed-Solomon (RS) Codes:} The undisputed champion of fixing "burst errors"---long strings of corrupted data. Instead of checking individual bits, it checks entire bytes. This is why a CD or DVD can have a significant scratch and still play perfectly. RS codes are also the magic behind QR codes, allowing them to be scanned even when partially damaged.
    \end{itemize}

    \parhead{The trade-off} More powerful codes require more parity bits (overhead), which means less of the transmitted signal is dedicated to your actual data. The genius of these codes lies in providing the maximum amount of error protection for the minimum amount of overhead.
\end{nontechnical}


\subsection{Overview}

\keyterm{Block codes} are a fundamental class of Forward Error Correction (FEC) codes that operate on fixed-length blocks of data. An \keyterm{$(n,k)$ block code} takes a block of $k$ information symbols and adds $n-k$ redundant parity symbols to produce an $n$-symbol codeword. These codes are memoryless, meaning each block is encoded independently.

The power of a block code is determined by its \keyterm{minimum distance ($d_{\min}$)}, which dictates its ability to detect and correct errors. This chapter explores three of the most important families of block codes: Hamming, BCH, and Reed-Solomon.

\begin{keyconcept}
    The choice of block code is a fundamental design trade-off. Hamming codes are highly efficient for correcting single-bit errors (e.g., in memory). Reed-Solomon codes are optimal for correcting burst errors (e.g., on optical media). BCH codes provide a flexible middle ground. Modern systems often use even more powerful codes like LDPC, but these classical block codes remain foundational and widely used.
\end{keyconcept}


\subsection{Linear Block Codes}

Most practical block codes are \keyterm{linear}, which means the sum (XOR for binary codes) of any two valid codewords is also a valid codeword. This linear algebraic structure allows for highly efficient encoding and decoding using matrix operations.

\paragraph{Encoding}
Encoding is performed by multiplying the $k$-symbol data vector, $\mathbf{d}$, by a $k \times n$ \keyterm{generator matrix}, $G$:
\begin{equation}
    \mathbf{c} = \mathbf{d} \cdot G
\end{equation}
In a \keyterm{systematic} code, the generator matrix has the form $G = [I_k | P]$, which means the original data appears verbatim in the first $k$ positions of the codeword, followed by the $n-k$ parity symbols.

\paragraph{Decoding}
Decoding is performed using an $(n-k) \times n$ \keyterm{parity-check matrix}, $H$, which is defined such that for any valid codeword $\mathbf{c}$, $\mathbf{c}H^T = \mathbf{0}$. When a potentially corrupted vector $\mathbf{r}$ is received, the receiver computes the \keyterm{syndrome}:
\begin{equation}
    \mathbf{s} = \mathbf{r}H^T
\end{equation}
If $\mathbf{s} = \mathbf{0}$, no errors are detected. If $\mathbf{s} \neq \mathbf{0}$, its value uniquely identifies the error pattern (for a correctable number of errors), allowing the receiver to find and fix the corrupted bits.


\begin{workedexample}{The Hamming (7,4) Code}
    \parhead{Concept} The Hamming (7,4) code is a perfect, single-error-correcting linear block code. It takes 4 data bits and adds 3 parity bits, creating a 7-bit codeword. Its minimum distance is $d_{\min}=3$.
    
    \parhead{Capability} With $d_{\min}=3$, it can correct any single-bit error ($t_c = \lfloor(3-1)/2\rfloor = 1$) or detect any two-bit error ($t_d = 3-1 = 2$).

    \parhead{Encoding} Let the data be `1011`. The three parity bits are calculated via a set of XOR operations on the data bits. For this data, the parity bits are `001`. The transmitted systematic codeword is `1011001`.
    
    \parhead{Decoding} Imagine the 4th bit is flipped by noise, and `1010001` is received.
    \begin{derivationsteps}
        \step The receiver calculates the syndrome using the received vector and the parity-check matrix.
        \step The result of the syndrome calculation is `100` (binary 4).
        \step The non-zero syndrome indicates an error. Its value, 4, points directly to the position of the corrupted bit.
        \step The receiver flips the 4th bit of the received vector, perfectly restoring the original codeword `1011001`. The original data `1011` is then extracted.
    \end{derivationsteps}
\end{workedexample}


\subsection{BCH and Reed-Solomon Codes}

\paragraph{BCH Codes}
The \keyterm{Bose-Chaudhuri-Hocquenghem (BCH)} codes are a powerful family of cyclic codes that generalise the Hamming code to correct multiple bit errors. A BCH code is defined by its block length $n$ and its designed error-correction capability, $t$. They offer a flexible trade-off between performance and complexity and are widely used in applications like flash memory controllers.

\paragraph{Reed-Solomon (RS) Codes}
\keyterm{Reed-Solomon (RS)} codes are a non-binary subset of BCH codes. They operate on symbols (groups of bits) rather than individual bits. A typical RS code operates on bytes (8-bit symbols).
\begin{warningbox}
    The ability of Reed-Solomon codes to correct \textbf{symbol errors} makes them exceptionally powerful against \textbf{burst errors}. A single symbol error might correspond to 8 consecutive corrupted bits, but to the RS decoder, it is still just one error to fix. An RS(255,223) code, for instance, can correct up to 16 byte errors anywhere in its 255-byte block. This is why RS codes are the standard for storage media like CDs and DVDs, where a physical scratch can cause a long burst of bit errors.
\end{warningbox}

\begin{table}[H]
    \centering
    \caption{Comparison of Key Block Code Families}
    \label{tab:block-code-summary}
    \begin{tabularx}{\textwidth}{@{}lXXX@{}}
        \toprule
        \tableheaderfont Code Family & \tableheaderfont Key Feature & \tableheaderfont Error Type Handled Best & \tableheaderfont Primary Application \\
        \midrule
        Hamming & Perfect, single-error & Random single-bit errors & ECC Memory \\
        BCH & Multi-error correction & Random multiple-bit errors & Flash Storage (NAND) \\
        Reed-Solomon & Symbol-based, MDS* & Burst errors & Optical Media (CD/DVD), QR Codes \\
        \bottomrule
    \end{tabularx}
    \par\vspace{0.5em}
    \small *Maximum Distance Separable: provides the maximum possible error correction for its overhead.
\end{table}


\begin{importantbox}[title={Further Reading}]
    Classical block codes form the foundation of error correction, and their principles are essential for understanding modern coding theory.
    \begin{description}
        \item[Hamming Distance] (\Cref{ch:hamming-distance}) provides the mathematical basis for the error detection and correction capabilities described in this chapter.
        \item[LDPC and Turbo Codes] (\Cref{ch:ldpc}, \Cref{ch:turbo}) are modern, capacity-approaching codes that have largely superseded classical block codes in high-performance communication systems like 5G and WiFi.
        \item[Forward Error Correction] (\Cref{ch:fec}) provides a broader overview, placing block codes in context with other coding strategies like convolutional codes.
    \end{description}
\end{importantbox}