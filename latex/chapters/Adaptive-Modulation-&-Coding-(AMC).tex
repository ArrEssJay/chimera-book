\chapter{Adaptive Modulation \& Coding (AMC)}
\label{ch:amc}

\begin{nontechnical}
\textbf{AMC is like shifting gears in a car}---when the road is clear (good channel), you shift to high gear for maximum speed. When conditions worsen (poor channel), you shift to lower gears for reliability.

\textbf{Simple idea:}
\begin{itemize}
\item Good channel = 256-QAM (fast but fragile) $\rightarrow$ 100 Mbps
\item Moderate channel = 64-QAM (balanced) $\rightarrow$ 60 Mbps
\item Poor channel = QPSK (slow but reliable) $\rightarrow$ 10 Mbps
\end{itemize}

\textbf{Real use:} Your phone constantly adapts. Near a cell tower = fast 5G. Far away = slower but reliable connection.

\textbf{Why adapt?} Without AMC, systems fail in poor conditions or waste capacity in good conditions. AMC maximizes throughput while maintaining quality across all scenarios.
\end{nontechnical}

\section{Overview}

\textbf{Adaptive Modulation and Coding (AMC)} dynamically adjusts transmission parameters---modulation order, code rate, and transmit power---based on real-time channel state information (CSI) to maximize spectral efficiency while maintaining target error rates.

\begin{keyconcept}
AMC enables wireless systems to \textbf{track Shannon capacity} in time-varying channels by matching the instantaneous data rate to channel quality. This provides \textbf{2--5$\times$ throughput gain} compared to fixed modulation in fading environments.
\end{keyconcept}

AMC is fundamental to all modern wireless standards: LTE (3GPP), 5G NR, WiFi 6/7 (802.11ax/be), and forms the basis for link adaptation in cellular and wireless local area networks.

\section{Mathematical Description}

\subsection{Shannon Capacity Foundation}

AMC is motivated by Shannon's channel capacity theorem, which gives the maximum achievable data rate:
\begin{equation}
C = B \log_2(1 + \text{SNR})
\end{equation}
where:
\begin{itemize}
\item $C$ = channel capacity (bits/second)
\item $B$ = bandwidth (Hz)
\item $\text{SNR}$ = signal-to-noise ratio (linear, not dB)
\end{itemize}

For time-varying channels, the instantaneous SNR $\gamma(t)$ fluctuates due to fading:
\begin{equation}
C(t) = B \log_2(1 + \gamma(t))
\end{equation}

\textbf{Fixed modulation problem:} If we select a single modulation/coding scheme (MCS) for average SNR $\bar{\gamma}$, the system experiences:
\begin{itemize}
\item \textbf{Outage} when $\gamma(t) < \gamma_{\text{threshold}}$ (data errors)
\item \textbf{Underutilization} when $\gamma(t) \gg \gamma_{\text{threshold}}$ (wasted capacity)
\end{itemize}

\subsection{Adaptive Rate Selection}

AMC selects data rate $R(t)$ to match instantaneous capacity:
\begin{equation}
R(t) = \eta(\gamma(t)) \cdot B
\end{equation}
where:
\begin{itemize}
\item $\eta(\gamma)$ = spectral efficiency function (bits/s/Hz)
\item $\eta(\gamma) \leq \log_2(1 + \gamma)$ (Shannon limit with implementation gap)
\end{itemize}

\textbf{Spectral efficiency} depends on modulation order $M$ and code rate $r$:
\begin{equation}
\eta = r \cdot \log_2(M)
\end{equation}
where:
\begin{itemize}
\item $M \in \{2, 4, 16, 64, 256, 1024\}$ = modulation constellation size (BPSK, QPSK, 16-QAM, 64-QAM, 256-QAM, 1024-QAM)
\item $r \in [1/3, 7/8]$ = forward error correction code rate
\end{itemize}

\subsection{The AMC Concept}

AMC operates by maintaining a lookup table mapping SNR to MCS index:

\begin{center}
\begin{tikzpicture}[scale=1.1,
  level/.style={rectangle, draw, minimum width=5cm, minimum height=0.8cm, font=\sffamily\small, fill=black!5},
  node distance=0.9cm
]
% AMC ladder showing modulation schemes
\node[level, fill=green!20] (mcs5) at (0,4) {256-QAM, Rate-5/6 $\rightarrow$ 7.4 bits/s/Hz};
\node[right=0.3cm of mcs5, font=\scriptsize] {SNR $>$ 30 dB};

\node[level, fill=green!10] (mcs4) at (0,3) {64-QAM, Rate-3/4 $\rightarrow$ 4.5 bits/s/Hz};
\node[right=0.3cm of mcs4, font=\scriptsize] {SNR = 20--30 dB};

\node[level, fill=yellow!20] (mcs3) at (0,2) {16-QAM, Rate-1/2 $\rightarrow$ 2.0 bits/s/Hz};
\node[right=0.3cm of mcs3, font=\scriptsize] {SNR = 12--20 dB};

\node[level, fill=orange!20] (mcs2) at (0,1) {QPSK, Rate-1/2 $\rightarrow$ 1.0 bits/s/Hz};
\node[right=0.3cm of mcs2, font=\scriptsize] {SNR = 5--12 dB};

\node[level, fill=red!20] (mcs1) at (0,0) {BPSK, Rate-1/3 $\rightarrow$ 0.33 bits/s/Hz};
\node[right=0.3cm of mcs1, font=\scriptsize] {SNR $<$ 5 dB};

% Arrows indicating adaptation
\draw[->,thick,dashed] (mcs1.east) to[out=0,in=0] node[right,font=\scriptsize,align=left] {Channel\\improves} (mcs5.east);
\draw[->,thick,dashed] (mcs5.west) to[out=180,in=180] node[left,font=\scriptsize,align=right] {Channel\\degrades} (mcs1.west);

\node[above=0.3cm of mcs5, font=\sffamily\bfseries] {AMC Adaptation Ladder};
\end{tikzpicture}
\end{center}

\textbf{Key insight:} The system continuously monitors SNR and selects the highest-rate MCS that maintains target BER $\leq 10^{-3}$ (or BLER $\leq 10\%$).

\subsection{MCS Selection Thresholds}

The MCS selection function maps instantaneous SNR to modulation and code rate:
\begin{equation}
\text{MCS}(t) = \arg\max_i \{\eta_i : \gamma(t) \geq \gamma_{\text{threshold},i}\}
\end{equation}
where:
\begin{itemize}
\item $\text{MCS}(t)$ = selected modulation and coding scheme at time $t$
\item $\eta_i$ = spectral efficiency of MCS index $i$ (bits/s/Hz)
\item $\gamma_{\text{threshold},i}$ = minimum SNR required for target BER with MCS $i$
\end{itemize}

Typical thresholds for BER $= 10^{-3}$ after FEC:

\begin{center}
\begin{tabular}{@{}llcc@{}}
\toprule
\textbf{MCS} & \textbf{Modulation} & \textbf{Code Rate} & \textbf{Threshold SNR (dB)} \\
\midrule
0 & BPSK & 1/3 & $-2$ \\
5 & QPSK & 1/2 & 5 \\
10 & 16-QAM & 1/2 & 12 \\
15 & 64-QAM & 3/4 & 20 \\
20 & 256-QAM & 5/6 & 30 \\
\bottomrule
\end{tabular}
\end{center}

\section{Link Adaptation Framework}

\subsection{Feedback Loop Architecture}

AMC requires a closed-loop feedback system:

\begin{center}
\begin{tikzpicture}[
  block/.style={rectangle, draw, minimum width=2.5cm, minimum height=1cm, font=\sffamily\small, fill=white},
  node distance=2.5cm,
  font=\small
]
% Transmitter side
\node[block] (encoder) {Data\\Encoder};
\node[block, right of=encoder, node distance=3cm] (modulator) {Adaptive\\Modulator};
\node[block, right of=modulator, node distance=3cm] (channel) {Fading\\Channel};

% Receiver side
\node[block, below of=channel, node distance=2.5cm] (demod) {Demodulator\\+ Decoder};
\node[block, left of=demod, node distance=3cm] (cqi) {CQI\\Estimator};
\node[block, left of=cqi, node distance=3cm] (scheduler) {MCS\\Selector};

% MCS table
\node[block, below of=modulator, node distance=2.5cm, minimum width=2cm] (mcs) {MCS\\Table};

% Forward path
\draw[->,thick] (encoder) -- node[above,font=\scriptsize] {bits} (modulator);
\draw[->,thick] (modulator) -- node[above,font=\scriptsize] {$s(t)$} (channel);
\draw[->,thick] (channel) -- node[right,font=\scriptsize] {$r(t)$} (demod);

% Feedback path
\draw[->,thick] (demod) -- (cqi);
\draw[->,thick] (cqi) -- node[above,font=\scriptsize] {CQI} (scheduler);
\draw[->,thick,dashed] (scheduler) |- node[left,font=\scriptsize,pos=0.3] {MCS cmd} (mcs);
\draw[->,thick] (mcs) -- node[right,font=\scriptsize] {$M$, $r$} (modulator);

% Channel estimation
\node[below of=channel, node distance=1.2cm, font=\scriptsize, align=center] (pilot) {Pilot\\symbols};
\draw[->,dashed] (channel) -- (pilot);
\draw[->,dashed] (pilot) -| (cqi);

\node[above=0.2cm of channel, font=\sffamily\bfseries] {AMC Feedback Loop};
\end{tikzpicture}
\end{center}

\textbf{Process steps:}
\begin{enumerate}
\item \textbf{Receiver measures} channel quality via pilot/reference signals
\item \textbf{CQI estimation}: Quantize SNR to discrete feedback index
\item \textbf{Feedback transmission}: Send CQI to transmitter (uplink control channel)
\item \textbf{MCS selection}: Transmitter maps CQI to optimal MCS
\item \textbf{Data transmission}: Use selected modulation and code rate
\end{enumerate}

\subsection{Channel State Information (CSI)}

Channel state information quantifies the instantaneous link quality. For OFDM systems with $N$ subcarriers:
\begin{equation}
\text{SNR}_k = \frac{|H_k|^2 P_k}{N_0 B/N}
\end{equation}
where:
\begin{itemize}
\item $H_k$ = complex channel gain on subcarrier $k$
\item $P_k$ = transmit power on subcarrier $k$ (Watts)
\item $N_0$ = noise spectral density (W/Hz)
\item $B/N$ = subcarrier spacing (Hz)
\end{itemize}

\textbf{CSI acquisition methods:}

\begin{enumerate}
\item \textbf{Downlink (Base Station $\rightarrow$ User)}:
  \begin{itemize}
  \item BS transmits pilot/reference signals at known locations
  \item UE measures $H_k$ per subcarrier (amplitude, phase)
  \item UE computes CQI and sends via uplink control channel
  \item Feedback delay: typically 4--8 ms (LTE/5G)
  \end{itemize}

\item \textbf{Uplink (User $\rightarrow$ Base Station)}:
  \begin{itemize}
  \item UE transmits sounding reference signal (SRS)
  \item BS measures channel directly (reciprocity in TDD systems)
  \item No feedback delay (instantaneous adaptation possible)
  \end{itemize}
\end{enumerate}

\subsection{Channel Quality Indicator (CQI)}

CQI is a quantized representation of channel quality, mapping wideband or per-subcarrier SNR to a discrete index:
\begin{equation}
\text{CQI} = Q(\gamma_{\text{eff}})
\end{equation}
where:
\begin{itemize}
\item $Q(\cdot)$ = quantization function (typically 4--5 bits $\rightarrow$ 16--32 CQI levels)
\item $\gamma_{\text{eff}}$ = effective SNR accounting for frequency-selective fading
\end{itemize}

\textbf{Effective SNR computation} (Exponential Effective SINR Mapping):
\begin{equation}
\gamma_{\text{eff}} = -\beta \ln\left(\frac{1}{N}\sum_{k=1}^{N} e^{-\gamma_k/\beta}\right)
\end{equation}
where:
\begin{itemize}
\item $\gamma_k$ = SNR on subcarrier $k$ (linear)
\item $\beta$ = calibration parameter (depends on modulation, typically $\beta \approx 1.5$)
\item $N$ = number of subcarriers in resource allocation
\end{itemize}

\begin{calloutbox}{Why Effective SNR?}
Simple averaging $\bar{\gamma} = \frac{1}{N}\sum \gamma_k$ is inaccurate for coded systems. Deep fades on a few subcarriers cause disproportionate errors. EESM/MIESM methods accurately predict post-FEC performance by accounting for worst subcarriers.
\end{calloutbox}

\textbf{CQI-to-MCS mapping} (LTE example):

\begin{verbatim}
CQI = f(SINR, interference, fading statistics)

Mapping:
CQI  (Modulation, Code Rate)  Spectral Efficiency

Example (LTE):
CQI 1:  QPSK, Rate-1/8   0.15 bits/s/Hz (SINR < 0 dB)
CQI 5:  QPSK, Rate-1/2   1.0 bits/s/Hz (SINR  5 dB)
CQI 10: 64-QAM, Rate-3/4  4.5 bits/s/Hz (SINR  20 dB)
CQI 15: 256-QAM, Rate-7/8  7.0 bits/s/Hz (SINR  30 dB)

Target: <10% BLER (Block Error Rate) after first transmission
\end{verbatim}

\textbf{CQI calculation}:

\begin{verbatim}
Instantaneous SINR per subcarrier:
SINR = |H|² · P / (N + I)

where:
- H = channel gain on subcarrier k
- P = transmit power
- N = noise power
- I = interference power

Effective SINR (over all subcarriers):
SINR_eff = f(SINR, SINR, ..., SINR_N)

Methods:
1. Mean SINR: SINR_eff = mean(SINR)
2. EESM (Exponential Effective SINR Mapping):
   SINR_eff = -·ln(mean(exp(-SINR/)))
3. MIESM (Mutual Information ESM):
   SINR_eff based on mutual information

CQI = Quantize(SINR_eff)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Modulation and Coding Schemes
(MCS)}\label{modulation-and-coding-schemes-mcs}

\textbf{MCS Table (LTE example)}:

{\def\LTcaptype{} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1358}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1481}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1358}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2469}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
MCS Index
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Modulation
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Code Rate
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Spectral Eff. (bits/s/Hz)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Required SINR (dB)
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & QPSK & 0.076 & 0.15 & -6 \\
5 & QPSK & 0.439 & 0.88 & 2 \\
10 & 16-QAM & 0.478 & 1.91 & 10 \\
15 & 64-QAM & 0.553 & 3.32 & 18 \\
20 & 64-QAM & 0.750 & 4.50 & 24 \\
28 & 256-QAM & 0.926 & 7.41 & 32 \\
\end{longtable}
}

\textbf{Selection algorithm}:

\begin{verbatim}
Given CQI (estimated SINR):
1. Find highest MCS where SINR  Required_SINR
2. Verify: Predicted_BLER < 10%
3. Transmit with selected MCS

If BLER > 10% (ACK/NACK feedback):
 Fall back to lower MCS (more robust)

If BLER < 1% (excellent channel):
 Attempt higher MCS (increase throughput)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ Hybrid ARQ
(HARQ)}{ Hybrid ARQ (HARQ)}}\label{hybrid-arq-harq}

\textbf{Automatic Repeat Request} with \textbf{Forward Error
Correction}-\/-\/-retransmissions carry additional redundancy.

\subsubsection{HARQ Types}\label{harq-types}

\textbf{Type I - Chase Combining}:

\begin{verbatim}
First transmission: Original codeword
Retransmission(s): Same codeword (identical)

Receiver: Combine multiple copies (soft combining)
 Effective SNR increases with each retransmission

Example:
- TX 1: SNR = 5 dB  NACK (failed)
- TX 2: SNR = 5 dB  Combined SNR = 8 dB  ACK 

Advantage: Simple
Disadvantage: No incremental redundancy
\end{verbatim}

\textbf{Type II/III - Incremental Redundancy (IR)}:

\begin{verbatim}
First transmission: High code rate (less redundancy)
Retransmission 1: Additional parity bits (lower effective rate)
Retransmission 2: Even more parity (lowest rate)

Example (Rate-compatible punctured code):
- TX 1: Rate-3/4 (fast, fragile)  NACK
- TX 2: Rate-2/3 (add parity)  Combined rate-1/2  NACK
- TX 3: Rate-1/2 (add more parity)  Combined rate-1/3  ACK 

Advantage: Adaptive coding without re-encoding
Disadvantage: More complex receiver (soft buffer management)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{HARQ in LTE/5G}\label{harq-in-lte5g}

\textbf{LTE HARQ process}:

\begin{verbatim}
8 parallel HARQ processes (downlink), 8 (uplink)
RTT (Round-Trip Time): 8 ms
Max retransmissions: 4 (configurable)

Timeline:
t = 0 ms:    TX initial transmission (Process 0)
t = 4 ms:    RX decodes, sends ACK/NACK
t = 8 ms:    If NACK, retransmit (Process 0)
             Meanwhile, Process 1-7 active (pipelined)

Result: 8 simultaneous processes  continuous transmission
\end{verbatim}

\textbf{5G NR HARQ}:

\begin{verbatim}
16+ parallel HARQ processes (flexible)
RTT: 2-8 ms (depends on numerology)
Adaptive retransmission:
- Same MCS (Chase combining)
- Different MCS (adapt to channel change)
- Different RV (Redundancy Version) for IR
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ AMC Performance
Analysis}{ AMC Performance Analysis}}\label{amc-performance-analysis}

\subsubsection{Shannon-Capacity
Tracking}\label{shannon-capacity-tracking}

\textbf{Ideal AMC} approaches Shannon capacity:

\begin{verbatim}
C(SNR) = B · log(1 + SNR)

Without AMC (fixed QPSK, rate-1/2):
R_fixed = B · 1 bits/s/Hz (for all SNR)
Efficiency: R_fixed / C(SNR) = low at high SNR

With AMC:
R_AMC(SNR)  C(SNR) - 

where  = implementation gap (typically 2-5 dB from Shannon)

Throughput gain: 3-5× in typical fading scenarios
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Throughput in Fading
Channels}\label{throughput-in-fading-channels}

\textbf{Rayleigh fading channel} (urban/indoor):

\begin{verbatim}
Instantaneous SNR:  (exponentially distributed)
Average SNR: 

Outage probability:
P_out(R) = P(C() < R) = 1 - exp(-R / ( · B))

Without AMC (fixed rate R):
- Outage when  < _threshold  complete failure
- Average throughput: R · (1 - P_out)

With AMC:
- Adapt R = C() continuously
- No outage (always some rate achievable)
- Average throughput: E[C()] = ^ C() · p() d

Ergodic capacity:
C_ergodic = B · E[log(1 + )]

For Rayleigh: C_ergodic  B · log(e · ) (high SNR)
\end{verbatim}

\textbf{Numerical example}:

\begin{verbatim}
Channel: Rayleigh fading,  = 20 dB, B = 20 MHz

Fixed 64-QAM (rate-3/4):
- Required SNR: 18 dB
- Outage: P( < 18 dB) = 37%
- Average throughput: 4.5 × 20 MHz × 0.63 = 57 Mbps

AMC (QPSK to 256-QAM):
- Always adapts to channel
- Average throughput:  100 Mbps

Gain: 1.75× throughput improvement
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ AMC in
Standards}{ AMC in Standards}}\label{amc-in-standards}

\subsubsection{LTE Adaptive Modulation}\label{lte-adaptive-modulation}

\textbf{Downlink (eNodeB \$\textbackslash rightarrow\$ UE)}:

\begin{verbatim}
CQI reporting:
- Periodicity: 5-10 ms (semi-static)
- Wideband or subband (per RB - Resource Block)
- UE measures RSRP, RSRQ, SINR  computes CQI

MCS selection:
- eNodeB scheduler receives CQI
- Selects MCS per UE per RB
- Goals: Maximize cell throughput, maintain fairness

Resource allocation:
- Time-frequency (OFDMA)
- 1 RB = 12 subcarriers × 1 slot (0.5 ms)
- Assign high MCS to users with good CQI
\end{verbatim}

\textbf{Uplink (UE \$\textbackslash rightarrow\$ eNodeB)}:

\begin{verbatim}
UE transmits SRS (Sounding Reference Signal)
eNodeB measures channel directly (TDD reciprocity helps)
eNodeB commands MCS via PDCCH (Physical Downlink Control Channel)

Uplink challenges:
- Limited UE power  coverage-limited
- Lower MCS typical (vs. downlink)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{5G NR Ultra-Lean Design}\label{g-nr-ultra-lean-design}

\textbf{Dynamic adaptation}:

\begin{verbatim}
Ultra-flexible frame structure:
- Slot duration: 0.125-1 ms (depends on numerology)
- Mini-slots: <1 ms (ultra-low latency)
- HARQ feedback: 2-4 slots (faster than LTE)

Beam management:
- Massive MIMO: Beamformed transmissions
- CSI-RS: Beam-specific channel measurement
- Adapt MCS per beam (spatial dimension)

Grant-free transmission (URLLC):
- Pre-configured MCS (no dynamic CQI)
- Used for ultra-reliable, low-latency (factory automation)
\end{verbatim}

\textbf{Massive MIMO adaptation}:

\begin{verbatim}
Per-user MCS:
- User 1 (cell center, high SINR): 256-QAM, rate-5/6
- User 2 (cell edge, low SINR): QPSK, rate-1/3
- Simultaneous (MU-MIMO) on same resource blocks

Spectral efficiency:
Sum rate = _{i} R_i (bits/s/Hz per user)
         = 7 + 1 = 8 bits/s/Hz (vs. 4 for single-user)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{WiFi 6/7 (802.11ax/be)}\label{wifi-67-802.11axbe}

\textbf{Rate adaptation}:

\begin{verbatim}
WiFi metrics:
- RSSI (Received Signal Strength Indicator)
- PER (Packet Error Rate)
- Retry count

MCS selection:
- Minstrel / SampleRate algorithms (open-source)
- Proprietary vendor algorithms (Cisco, Qualcomm)
- Test higher MCS occasionally (probing)

Spatial stream adaptation:
- 1 stream: Long range, reliable
- 4 streams: Short range, high throughput
- Adapt based on distance, interference

Example (WiFi 6, 80 MHz):
- Close (1 m): 4 streams, 1024-QAM, rate-5/6  1.2 Gbps
- Medium (10 m): 2 streams, 256-QAM, rate-3/4  600 Mbps
- Far (50 m): 1 stream, QPSK, rate-1/2  30 Mbps
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ Advanced AMC
Techniques}{ Advanced AMC Techniques}}\label{advanced-amc-techniques}

\subsubsection{Outer-Loop Link Adaptation
(OLLA)}\label{outer-loop-link-adaptation-olla}

\textbf{Motivation}: CQI can be inaccurate (channel estimation errors,
feedback delay).

\textbf{OLLA principle}:

\begin{verbatim}
Adjust MCS based on ACK/NACK history, not just CQI.

Algorithm:
1. Start with MCS based on CQI
2. If NACK: Decrease MCS (_down = 1 dB)
3. If ACK: Increase MCS (_up = 0.01 dB)

Asymmetric adjustment:
- Fast decrease (avoid errors)
- Slow increase (test cautiously)

Result: Converges to optimal MCS despite CQI errors
\end{verbatim}

\textbf{Implementation}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ olla\_adaptation(cqi, ack\_history, target\_bler}\OperatorTok{=}\FloatTok{0.1}\NormalTok{):}
    \CommentTok{"""}
\CommentTok{    Outer{-}loop link adaptation.}
\CommentTok{    }
\CommentTok{    Args:}
\CommentTok{        cqi: Reported channel quality indicator}
\CommentTok{        ack\_history: Recent ACK/NACK outcomes}
\CommentTok{        target\_bler: Target block error rate}
\CommentTok{    }
\CommentTok{    Returns:}
\CommentTok{        Adjusted MCS index}
\CommentTok{    """}
\NormalTok{    mcs\_base }\OperatorTok{=}\NormalTok{ cqi\_to\_mcs(cqi)}
    
    \CommentTok{\# Compute recent BLER}
\NormalTok{    recent\_bler }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ np.mean(ack\_history)}
    
    \CommentTok{\# Offset adjustment}
    \ControlFlowTok{if}\NormalTok{ recent\_bler }\OperatorTok{\textgreater{}}\NormalTok{ target\_bler:}
\NormalTok{        offset\_db }\OperatorTok{=} \OperatorTok{{-}}\FloatTok{1.0}  \CommentTok{\# More conservative}
    \ControlFlowTok{elif}\NormalTok{ recent\_bler }\OperatorTok{\textless{}}\NormalTok{ target\_bler }\OperatorTok{/} \DecValTok{2}\NormalTok{:}
\NormalTok{        offset\_db }\OperatorTok{=} \OperatorTok{+}\FloatTok{0.5}  \CommentTok{\# More aggressive}
    \ControlFlowTok{else}\NormalTok{:}
\NormalTok{        offset\_db }\OperatorTok{=} \FloatTok{0.0}  \CommentTok{\# Stay}
    
    \CommentTok{\# Adjust MCS}
\NormalTok{    mcs\_adjusted }\OperatorTok{=}\NormalTok{ mcs\_base }\OperatorTok{+} \BuiltInTok{int}\NormalTok{(offset\_db }\OperatorTok{/} \DecValTok{2}\NormalTok{)  }\CommentTok{\# \textasciitilde{}2 dB per MCS}
\NormalTok{    mcs\_adjusted }\OperatorTok{=}\NormalTok{ np.clip(mcs\_adjusted, }\DecValTok{0}\NormalTok{, }\DecValTok{28}\NormalTok{)}
    
    \ControlFlowTok{return}\NormalTok{ mcs\_adjusted}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Cross-Layer Optimization}\label{cross-layer-optimization}

\textbf{Joint optimization} of PHY (MCS) and MAC (scheduling):

\textbf{Proportional Fair Scheduler}:

\begin{verbatim}
Maximize: _{i} log(R_i)  (sum log throughput)

User priority:
Priority_i = R_instantaneous_i / R_average_i

where:
- R_instantaneous: Rate achievable now (AMC-selected MCS)
- R_average: Long-term average throughput

Result:
- User with good channel gets high MCS  high R_instantaneous
- If already has high R_average, priority decreases
- Balances throughput and fairness
\end{verbatim}

\textbf{Buffer-aware AMC}:

\begin{verbatim}
If buffer almost empty:
 Use lower MCS (reliable, avoid stalls)

If buffer full:
 Use higher MCS (aggressive, drain buffer)

Delay-sensitive (VoIP):
 Conservative MCS (avoid retransmissions)

Throughput-oriented (file download):
 Aggressive MCS (maximize rate, tolerate retries)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Predictive AMC}\label{predictive-amc}

\textbf{Anticipate channel changes} before they occur.

\textbf{Method 1 - Doppler-based prediction}:

\begin{verbatim}
High mobility (vehicular):
- Channel changes rapidly (coherence time ~10 ms)
- CQI feedback outdated by RTT (8 ms)

Prediction:
1. Estimate Doppler shift (f_D = v/)
2. Predict channel evolution: H(t + t) = f(H(t), f_D)
3. Select MCS for predicted channel

Autoregressive model:
H[n+1] = a·H[n] + a·H[n-1] + ... + noise

Wiener filter / Kalman filter for prediction
\end{verbatim}

\textbf{Method 2 - Machine learning}:

\begin{verbatim}
Train neural network:
- Input: [H[n], H[n-1], ..., H[n-k], velocity, location]
- Output: H[n+1] (predicted channel)

Online learning:
- Update weights based on prediction error
- Adapt to user-specific channel patterns

Benefit: 2-3 dB gain in high-mobility scenarios
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ Python Implementation
Example}{ Python Implementation Example}}\label{python-implementation-example}

\subsubsection{AMC Simulator}\label{amc-simulator}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\KeywordTok{def}\NormalTok{ generate\_fading\_channel(n\_samples, coherence\_time}\OperatorTok{=}\DecValTok{100}\NormalTok{):}
    \CommentTok{"""}
\CommentTok{    Generate Rayleigh fading channel (Clarke\textquotesingle{}s model).}
\CommentTok{    }
\CommentTok{    Args:}
\CommentTok{        n\_samples: Number of time samples}
\CommentTok{        coherence\_time: Channel coherence (samples)}
\CommentTok{    }
\CommentTok{    Returns:}
\CommentTok{        Channel gains (linear)}
\CommentTok{    """}
    \CommentTok{\# Generate complex Gaussian samples}
\NormalTok{    h\_i }\OperatorTok{=}\NormalTok{ np.random.randn(n\_samples)}
\NormalTok{    h\_q }\OperatorTok{=}\NormalTok{ np.random.randn(n\_samples)}
\NormalTok{    h }\OperatorTok{=}\NormalTok{ (h\_i }\OperatorTok{+} \OtherTok{1j}\OperatorTok{*}\NormalTok{h\_q) }\OperatorTok{/}\NormalTok{ np.sqrt(}\DecValTok{2}\NormalTok{)}
    
    \CommentTok{\# Low{-}pass filter (coherence time)}
    \ImportTok{from}\NormalTok{ scipy.signal }\ImportTok{import}\NormalTok{ butter, lfilter}
\NormalTok{    b, a }\OperatorTok{=}\NormalTok{ butter(}\DecValTok{3}\NormalTok{, }\DecValTok{1}\OperatorTok{/}\NormalTok{coherence\_time)}
\NormalTok{    h }\OperatorTok{=}\NormalTok{ lfilter(b, a, h)}
    
    \CommentTok{\# Normalize to unit average power}
\NormalTok{    h }\OperatorTok{/=}\NormalTok{ np.sqrt(np.mean(np.}\BuiltInTok{abs}\NormalTok{(h)}\OperatorTok{**}\DecValTok{2}\NormalTok{))}
    
    \ControlFlowTok{return}\NormalTok{ h}

\KeywordTok{def}\NormalTok{ snr\_to\_cqi(snr\_db):}
    \CommentTok{"""}
\CommentTok{    Map SNR to CQI index (0{-}15).}
\CommentTok{    """}
\NormalTok{    cqi\_table }\OperatorTok{=}\NormalTok{ [}
\NormalTok{        (}\OperatorTok{{-}}\DecValTok{6}\NormalTok{, }\DecValTok{0}\NormalTok{), (}\DecValTok{0}\NormalTok{, }\DecValTok{5}\NormalTok{), (}\DecValTok{5}\NormalTok{, }\DecValTok{8}\NormalTok{), (}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{), }
\NormalTok{        (}\DecValTok{15}\NormalTok{, }\DecValTok{13}\NormalTok{), (}\DecValTok{20}\NormalTok{, }\DecValTok{15}\NormalTok{), (}\DecValTok{25}\NormalTok{, }\DecValTok{15}\NormalTok{)}
\NormalTok{    ]}
    \ControlFlowTok{for}\NormalTok{ snr\_thresh, cqi }\KeywordTok{in}\NormalTok{ cqi\_table:}
        \ControlFlowTok{if}\NormalTok{ snr\_db }\OperatorTok{\textless{}}\NormalTok{ snr\_thresh:}
            \ControlFlowTok{return} \BuiltInTok{max}\NormalTok{(}\DecValTok{0}\NormalTok{, cqi }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}
    \ControlFlowTok{return} \DecValTok{15}

\KeywordTok{def}\NormalTok{ cqi\_to\_mcs(cqi):}
    \CommentTok{"""}
\CommentTok{    Map CQI to MCS parameters.}
\CommentTok{    }
\CommentTok{    Returns:}
\CommentTok{        (modulation\_order, code\_rate, spectral\_efficiency)}
\CommentTok{    """}
\NormalTok{    mcs\_table }\OperatorTok{=}\NormalTok{ [}
\NormalTok{        (}\DecValTok{2}\NormalTok{, }\FloatTok{0.08}\NormalTok{, }\FloatTok{0.15}\NormalTok{),   }\CommentTok{\# CQI 0{-}1: QPSK}
\NormalTok{        (}\DecValTok{2}\NormalTok{, }\FloatTok{0.44}\NormalTok{, }\FloatTok{0.88}\NormalTok{),   }\CommentTok{\# CQI 5: QPSK}
\NormalTok{        (}\DecValTok{4}\NormalTok{, }\FloatTok{0.48}\NormalTok{, }\FloatTok{1.91}\NormalTok{),   }\CommentTok{\# CQI 10: 16{-}QAM}
\NormalTok{        (}\DecValTok{6}\NormalTok{, }\FloatTok{0.55}\NormalTok{, }\FloatTok{3.32}\NormalTok{),   }\CommentTok{\# CQI 15: 64{-}QAM}
\NormalTok{        (}\DecValTok{8}\NormalTok{, }\FloatTok{0.93}\NormalTok{, }\FloatTok{7.41}\NormalTok{),   }\CommentTok{\# CQI 15+: 256{-}QAM}
\NormalTok{    ]}
\NormalTok{    idx }\OperatorTok{=} \BuiltInTok{min}\NormalTok{(cqi }\OperatorTok{//} \DecValTok{4}\NormalTok{, }\BuiltInTok{len}\NormalTok{(mcs\_table) }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}
    \ControlFlowTok{return}\NormalTok{ mcs\_table[idx]}

\KeywordTok{def}\NormalTok{ compute\_bler(snr\_db, mcs\_params):}
    \CommentTok{"""}
\CommentTok{    Compute Block Error Rate for given SNR and MCS.}
\CommentTok{    }
\CommentTok{    Uses Shannon bound approximation.}
\CommentTok{    """}
\NormalTok{    mod\_order, code\_rate, spec\_eff }\OperatorTok{=}\NormalTok{ mcs\_params}
    
    \CommentTok{\# Required SNR for target BER = 10\^{}{-}6}
\NormalTok{    required\_snr }\OperatorTok{=}\NormalTok{ \{}
        \DecValTok{2}\NormalTok{: }\FloatTok{9.6}\NormalTok{,   }\CommentTok{\# QPSK}
        \DecValTok{4}\NormalTok{: }\FloatTok{16.5}\NormalTok{,  }\CommentTok{\# 16{-}QAM}
        \DecValTok{6}\NormalTok{: }\FloatTok{22.0}\NormalTok{,  }\CommentTok{\# 64{-}QAM}
        \DecValTok{8}\NormalTok{: }\FloatTok{28.0}\NormalTok{,  }\CommentTok{\# 256{-}QAM}
\NormalTok{    \}[mod\_order]}
    
    \CommentTok{\# Adjust for code rate}
\NormalTok{    required\_snr }\OperatorTok{{-}=} \DecValTok{10} \OperatorTok{*}\NormalTok{ np.log10(code\_rate)}
    
    \CommentTok{\# BLER approximation (exponential model)}
    \ControlFlowTok{if}\NormalTok{ snr\_db }\OperatorTok{\textgreater{}}\NormalTok{ required\_snr:}
\NormalTok{        bler }\OperatorTok{=}\NormalTok{ np.exp(}\OperatorTok{{-}}\FloatTok{0.5} \OperatorTok{*}\NormalTok{ (snr\_db }\OperatorTok{{-}}\NormalTok{ required\_snr))}
    \ControlFlowTok{else}\NormalTok{:}
\NormalTok{        bler }\OperatorTok{=} \FloatTok{0.5}  \CommentTok{\# High error rate}
    
    \ControlFlowTok{return} \BuiltInTok{min}\NormalTok{(bler, }\FloatTok{0.5}\NormalTok{)}

\CommentTok{\# Simulation}
\NormalTok{n\_samples }\OperatorTok{=} \DecValTok{10000}
\NormalTok{avg\_snr\_db }\OperatorTok{=} \DecValTok{20}
\NormalTok{coherence\_time }\OperatorTok{=} \DecValTok{100}

\CommentTok{\# Generate fading channel}
\NormalTok{h }\OperatorTok{=}\NormalTok{ generate\_fading\_channel(n\_samples, coherence\_time)}
\NormalTok{snr\_inst }\OperatorTok{=}\NormalTok{ avg\_snr\_db }\OperatorTok{+} \DecValTok{20}\OperatorTok{*}\NormalTok{np.log10(np.}\BuiltInTok{abs}\NormalTok{(h))  }\CommentTok{\# Instantaneous SNR}

\CommentTok{\# AMC simulation}
\NormalTok{throughput\_amc }\OperatorTok{=}\NormalTok{ []}
\NormalTok{throughput\_fixed }\OperatorTok{=}\NormalTok{ []}
\NormalTok{bler\_amc }\OperatorTok{=}\NormalTok{ []}

\CommentTok{\# Fixed MCS (64{-}QAM, rate{-}3/4)}
\NormalTok{fixed\_mcs }\OperatorTok{=}\NormalTok{ (}\DecValTok{6}\NormalTok{, }\FloatTok{0.75}\NormalTok{, }\FloatTok{4.5}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ snr\_db }\KeywordTok{in}\NormalTok{ snr\_inst:}
    \CommentTok{\# AMC: Select MCS based on CQI}
\NormalTok{    cqi }\OperatorTok{=}\NormalTok{ snr\_to\_cqi(snr\_db)}
\NormalTok{    mcs }\OperatorTok{=}\NormalTok{ cqi\_to\_mcs(cqi)}
    
    \CommentTok{\# Compute BLER}
\NormalTok{    bler }\OperatorTok{=}\NormalTok{ compute\_bler(snr\_db, mcs)}
    
    \CommentTok{\# Throughput (accounting for retransmissions)}
\NormalTok{    tput\_amc }\OperatorTok{=}\NormalTok{ mcs[}\DecValTok{2}\NormalTok{] }\OperatorTok{*}\NormalTok{ (}\DecValTok{1} \OperatorTok{{-}}\NormalTok{ bler)  }\CommentTok{\# bits/s/Hz}
\NormalTok{    tput\_fixed }\OperatorTok{=}\NormalTok{ fixed\_mcs[}\DecValTok{2}\NormalTok{] }\OperatorTok{*}\NormalTok{ (}\DecValTok{1} \OperatorTok{{-}}\NormalTok{ compute\_bler(snr\_db, fixed\_mcs))}
    
\NormalTok{    throughput\_amc.append(tput\_amc)}
\NormalTok{    throughput\_fixed.append(tput\_fixed)}
\NormalTok{    bler\_amc.append(bler)}

\CommentTok{\# Results}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Average SNR: }\SpecialCharTok{\{}\NormalTok{avg\_snr\_db}\SpecialCharTok{\}}\SpecialStringTok{ dB"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"AMC average throughput: }\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{mean(throughput\_amc)}\SpecialCharTok{:.2f\}}\SpecialStringTok{ bits/s/Hz"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Fixed MCS throughput: }\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{mean(throughput\_fixed)}\SpecialCharTok{:.2f\}}\SpecialStringTok{ bits/s/Hz"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"AMC gain: }\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{mean(throughput\_amc) }\OperatorTok{/}\NormalTok{ np}\SpecialCharTok{.}\NormalTok{mean(throughput\_fixed)}\SpecialCharTok{:.2f\}}\SpecialStringTok{×"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"AMC average BLER: }\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{mean(bler\_amc)}\SpecialCharTok{:.2\%\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ When to Use
AMC}{ When to Use AMC}}\label{when-to-use-amc}

\subsubsection{AMC Excels:}\label{amc-excels}

\textbf{Time-varying channels} (mobility, fading)\\
\textbf{Wide SNR range} (cell-edge to cell-center users)\\
\textbf{Throughput-oriented} applications (web, video streaming)\\
\textbf{Multi-user systems} (fairness via per-user adaptation)\\
\textbf{OFDM systems} (per-subcarrier or per-RB adaptation)

\subsubsection{AMC Challenges:}\label{amc-challenges}

\textbf{Fast fading} (feedback delay \textgreater{} coherence time)\\
\textbf{Feedback overhead} (high for wideband, MIMO)\\
\textbf{Latency-sensitive} (delay from MCS switching)\\
\textbf{Low SNR regime} (limited MCS choices)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{\texorpdfstring{ Further
Reading}{ Further Reading}}\label{further-reading}

\subsubsection{Textbooks}\label{textbooks}

\begin{itemize}
\tightlist
\item
  \textbf{Goldsmith}, \emph{Wireless Communications} (Chapter 9:
  Adaptive Modulation) - Comprehensive treatment
\item
  \textbf{Tse \& Viswanath}, \emph{Fundamentals of Wireless
  Communication} (Chapter 5: Capacity of fading channels)
\item
  \textbf{Hanzo et al.}, \emph{Adaptive Wireless Transceivers} - Deep
  dive into AMC algorithms
\end{itemize}

\subsubsection{Key Papers}\label{key-papers}

\begin{itemize}
\tightlist
\item
  \textbf{Goldsmith \& Varaiya} (1997): ``Capacity of fading channels
  with CSI'' - Foundational theory
\item
  \textbf{Caire et al.} (1999): ``Optimum power control over fading
  channels'' - Water-filling for fading
\item
  \textbf{Ekström et al.} (2006): ``Technical Solutions for 3G LTE'' -
  Practical LTE AMC
\end{itemize}

\subsubsection{Standards Documents}\label{standards-documents}

\begin{itemize}
\tightlist
\item
  \textbf{3GPP TS 36.213}: LTE Physical Layer Procedures (CQI, MCS
  tables)
\item
  \textbf{3GPP TS 38.214}: 5G NR Physical Layer (AMC, HARQ)
\item
  \textbf{IEEE 802.11ax}: WiFi 6 (rate adaptation algorithms)
\end{itemize}

\subsubsection{Related Topics}\label{related-topics}

\begin{itemize}
\tightlist
\item
  {[}{[}Shannon\textquotesingle s-Channel-Capacity-Theorem{]}{]} -
  Theoretical foundation for AMC
\item
  {[}{[}OFDM-\&-Multicarrier-Modulation{]}{]} - Per-subcarrier
  adaptation
\item
  {[}{[}MIMO-\&-Spatial-Multiplexing{]}{]} - Per-stream MCS adaptation
\item
  {[}{[}Forward-Error-Correction-(FEC){]}{]} - Code rate adaptation
\item
  {[}{[}Real-World-System-Examples{]}{]} - LTE, 5G, WiFi implementations
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\textbf{Summary}: Adaptive Modulation and Coding (AMC) is the bridge
between
{[}{[}Shannon\textquotesingle s-Channel-Capacity-Theorem\textbar Shannon
theory{]}{]} and practical wireless systems. By dynamically selecting
modulation order (BPSK \$\textbackslash rightarrow\$ 256-QAM) and code
rate (1/3 \$\textbackslash rightarrow\$ 7/8) based on Channel Quality
Indicator (CQI) feedback, AMC systems track instantaneous channel
capacity and maximize throughput while maintaining target error rates
(typically \textless10\% BLER). LTE/5G use CQI reporting (1-15) mapped
to MCS tables, combined with HARQ for robustness. AMC provides
2-5\$\textbackslash times\$ throughput gain in fading channels compared
to fixed modulation. Outer-loop link adaptation (OLLA) corrects for CQI
errors. Cross-layer optimization integrates AMC with scheduling
(proportional fair) and buffer management. Predictive AMC uses Doppler
estimation or machine learning to anticipate channel changes. AMC is
essential for spectral efficiency in modern cellular and WiFi networks,
enabling gigabit-per-second data rates while serving users across wide
SNR ranges (cell-edge to cell-center).
