% ==============================================================================
% CHAPTER 30: Forward Error Correction (FEC)
% ==============================================================================

\chapter{Forward Error Correction (FEC)}
\label{ch:fec}

\begin{nontechnical}
    \textbf{Forward Error Correction (FEC) is like sending a message with a built-in "spell-checker".} It adds clever, structured redundancy to your data so that even if some bits get corrupted by noise, the receiver can figure out the original message.

    \parhead{The simple example: Repetition}
    Imagine you want to send the bit "1". Instead of sending it once, you send it three times: "111".
    \begin{itemize}
        \item If the receiver gets "111", the message is clear.
        \item If noise corrupts one bit and the receiver gets "101", it can make an intelligent guess: "I received two 1s and only one 0, so the original was probably a 1."
    \end{itemize}
    This is a simple form of FEC. Modern codes are vastly more sophisticated.

    \parhead{The trade-off: Reliability vs. Speed}
    Adding redundancy means you are sending extra bits, which slows down your effective data rate. A "rate-1/2" code, for example, sends one parity bit for every information bit, halving your data speed but making the link far more robust. Modern systems like 5G and WiFi constantly adjust the amount of FEC based on the signal quality---using less FEC when the signal is strong (for higher speeds) and more FEC when the signal is weak (for better reliability).

    \parhead{Where you see it}
    \begin{itemize}
        \item \textbf{QR Codes:} The error correction blocks in a QR code are a form of FEC, allowing it to be read even when partially damaged.
        \item \textbf{Satellite TV:} The signal from a satellite is incredibly weak. Powerful FEC is what allows your dish to produce a clear picture from a signal that is barely above the noise floor.
        \item \textbf{Deep Space Probes:} The Voyager probes are still communicating from interstellar space because of the powerful FEC codes designed in the 1970s.
    \end{itemize}
\end{nontechnical}


\section{Overview and Properties}

\subsection{Overview}

In any real communication channel, noise and interference are unavoidable, leading to bit errors at the receiver. \keyterm{Forward Error Correction (FEC)} is a technique that enables the receiver to detect and correct these errors without requiring a retransmission from the sender. This is achieved by adding carefully designed redundant bits, known as \keyterm{parity bits}, to the original information data before transmission.

\begin{keyconcept}
    FEC provides a trade-off between power efficiency and bandwidth efficiency. By adding redundancy (reducing bandwidth efficiency), a system can achieve a target Bit Error Rate (BER) at a much lower Signal-to-Noise Ratio. This improvement is known as \textbf{coding gain}, and it is a cornerstone of modern communication system design, enabling reliable communication in channels that would otherwise be unusable.
\end{keyconcept}


\subsection{Fundamental Concepts}

\paragraph{Code Rate ($R$)}
The code rate is the ratio of information bits ($k$) to the total number of transmitted bits ($n$). It measures the efficiency of the code.
\begin{equation}
    R = \frac{k}{n}
\end{equation}
A low-rate code (e.g., $R=1/3$) has high redundancy and is very robust, while a high-rate code (e.g., $R=7/8$) has low redundancy and is more efficient but less powerful.

\paragraph{Coding Gain}
The coding gain is the reduction in the required $E_b/N_0$ (in dB) to achieve a specific BER, compared to an uncoded system. Modern codes like \keyterm{LDPC (Low-Density Parity-Check)} and \keyterm{Turbo codes} can provide a coding gain of 8-11 dB, bringing system performance to within a fraction of a decibel of the theoretical Shannon limit.


\subsection{Major Classes of Codes}

\begin{description}
    \item[Block Codes] These codes operate on fixed-size blocks of data. The encoder takes a block of $k$ information bits and generates a block of $n$ coded bits. They are memoryless and well-suited for packet-based data. Examples include \keyterm{Hamming codes}, \keyterm{BCH codes}, and \keyterm{Reed-Solomon codes}, which are particularly effective at correcting burst errors and are famously used in CDs, DVDs, and QR codes. Modern \keyterm{LDPC codes} are also block codes and are the standard in 5G, WiFi 6, and DVB-S2.
    \item[Convolutional Codes] These codes operate on a continuous stream of data. The encoder has memory, and each output block depends on the current input block and several previous ones. They are typically decoded using the \keyterm{Viterbi algorithm}. Convolutional codes were the workhorse of satellite and deep-space communication for decades (e.g., the NASA standard code used on the Voyager probes).
\end{description}

\begin{table}[H]
    \centering
    \caption{Key FEC Codes and Their Primary Applications}
    \label{tab:fec-applications}
    \begin{tabular}{@{}lll@{}}
        \toprule
        \tableheaderfont Code Type & \tableheaderfont Key Feature & \tableheaderfont Primary Application(s) \\
        \midrule
        Reed-Solomon & Excellent burst error correction & Optical storage (CD/DVD), QR codes \\
        Convolutional & Good performance, low latency & Deep space, GSM (2G) \\
        Turbo Codes & Near-Shannon-limit performance & 3G/4G Cellular (UMTS/LTE) \\
        LDPC Codes & Near-Shannon-limit, parallelisable & 5G, WiFi 6, DVB-S2, Ethernet \\
        Polar Codes & Capacity-achieving, low complexity & 5G control channels \\
        \bottomrule
    \end{tabular}
\end{table}


\subsection{Hard vs. Soft Decision Decoding}

\paragraph{Hard-Decision Decoding}
The demodulator first makes a firm decision on each received bit (a '0' or a '1'). The FEC decoder then receives this stream of hard bits and attempts to correct errors based on the parity checks. This approach discards valuable information about the reliability of each decision.

\paragraph{Soft-Decision Decoding}
The demodulator does not make a hard decision. Instead, it passes the raw analogue or multi-bit digital value of each received symbol to the FEC decoder. This allows the decoder to know which bits are highly reliable and which are marginal (close to the decision boundary).
\begin{warningbox}
    \textbf{Soft-decision decoding provides a significant performance gain of approximately 2-3 dB} over hard-decision decoding. All modern high-performance codes (Turbo, LDPC, Polar) are designed specifically to use soft-decision inputs, typically in the form of Log-Likelihood Ratios (LLRs).
\end{warningbox}


\begin{workedexample}{Hamming (7,4) Code}
    \parhead{Concept} The Hamming (7,4) code is a classic and simple linear block code that can correct any single bit error in a 7-bit block. It takes 4 information bits and adds 3 parity bits.
    
    \parhead{Encoding Process}
    Let the 4 data bits be $(d_3, d_2, d_1, d_0)$. Three parity bits ($p_2, p_1, p_0$) are calculated using XOR operations:
    \begin{align*}
        p_2 &= d_3 \oplus d_2 \oplus d_1 \\
        p_1 &= d_3 \oplus d_2 \oplus d_0 \\
        p_0 &= d_3 \oplus d_1 \oplus d_0
    \end{align*}
    The final 7-bit codeword is transmitted as $(d_3, d_2, d_1, d_0, p_2, p_1, p_0)$.

    \parhead{Example}
    \begin{itemize}
        \item Information bits: `1011`.
        \item Parity bits: $p_2=0, p_1=0, p_0=1$.
        \item Transmitted codeword: `1011001`.
    \end{itemize}
    
    \parhead{Decoding Process}
    The receiver recalculates the parity checks based on the received data bits, creating a 3-bit "syndrome". If the syndrome is all zeros, there is no error. If it is non-zero, its binary value points directly to the position of the single bit that is in error.
    \begin{itemize}
        \item Received codeword (with one error): `10\textbf{0}1001`.
        \item The receiver calculates a syndrome of `101` (binary 5).
        \item This indicates that the 5th bit is wrong. The receiver flips it.
        \item Corrected codeword: `1011001`. The original data is recovered perfectly.
    \end{itemize}
\end{workedexample}


\begin{importantbox}[title={Further Reading}]
    Forward Error Correction is the key technology that allows practical systems to approach the theoretical limits of communication.
    \begin{description}
        \item[Shannon's Channel Capacity] (\Cref{ch:shannon}) is the theorem that proved powerful FEC codes must exist.
        \item[Bit Error Rate (BER)] (\Cref{ch:ber}) is the metric that quantifies the performance of an FEC code, often visualised in "waterfall" curves.
        \aitem[Modern Coding] The subsequent chapters on \textbf{LDPC Codes} and \textbf{Turbo Codes} provide a deep dive into the specific capacity-approaching codes that power today's high-speed communication systems.
    \end{description}
\end{importantbox}
