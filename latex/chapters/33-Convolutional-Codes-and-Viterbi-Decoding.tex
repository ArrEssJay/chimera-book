% ==============================================================================
% CHAPTER 33: Convolutional Codes & Viterbi Decoding
% ==============================================================================

\chapter{Convolutional Codes \& Viterbi Decoding}
\label{ch:convolutional-codes}

\begin{nontechnical}
    \textbf{Convolutional codes are like adding a "memory" to your data}, creating a continuous, flowing pattern. The Viterbi algorithm is like a detective that can follow this pattern to find and fix errors, even in very noisy signals.

    \parhead{The problem: Isolated bits are vulnerable}
    If you send a stream of independent 1s and 0s, and noise flips one bit, it's hard to know an error even occurred.

    \parhead{The convolutional solution: Create a pattern}
    Instead of encoding each bit by itself, a convolutional encoder looks at the current bit \emph{and} a few previous bits. The output bits are a function of this entire "window" of data. This creates a structural link, or memory, between consecutive bits. A single bit error in the input will now affect several output bits, creating a distinct pattern that the receiver can spot.

    \parhead{The Viterbi algorithm: Finding the most likely path}
    The Viterbi decoder is the real genius of the system. It works like a GPS navigator trying to reconstruct your route from a series of noisy location pings.
    \begin{itemize}
        \item It knows all the "valid roads" (the possible patterns the encoder can make).
        \item It looks at the entire sequence of noisy "pings" it has received.
        \item It then finds the one single valid path through the map of all possibilities that most closely matches the noisy sequence it observed.
    \end{itemize}
    By finding the "most likely path," it simultaneously decodes the data and corrects errors.

    \parhead{Real-world magic} This technique is so powerful that it allows us to communicate with the \textbf{Voyager space probes}, which are now in interstellar space. Their signals are billions of times weaker than the background noise, but because they use a convolutional code, the Viterbi algorithm on Earth can still pull the data out of the static. It was also the workhorse code for 2G mobile phones, early WiFi, and satellite TV.
\end{nontechnical}


\subsection{Overview}

\keyterm{Convolutional codes} are a class of forward error-correcting codes that differ from block codes in one fundamental way: they have \keyterm{memory}. The encoder processes a continuous stream of information bits, and each block of $n$ output bits depends not only on the current $k$ input bits but also on the previous $m$ input bits. This memory introduces a structure of dependencies into the coded stream.

This structure is best represented by a \keyterm{trellis diagram}, which maps all possible state transitions of the encoder over time. The optimal decoding of a convolutional code is then equivalent to finding the most likely path through this trellis, a problem that is solved efficiently and elegantly by the \keyterm{Viterbi algorithm}.

\begin{keyconcept}
    The combination of a convolutional encoder and a \textbf{Viterbi decoder} provides a powerful and practical method for achieving significant coding gain. For decades, this was the dominant FEC technique for power-limited channels, used in everything from deep-space probes to mobile phones, before the advent of capacity-approaching Turbo and LDPC codes.
\end{keyconcept}


\subsection{Encoder Structure and Parameters}

A convolutional encoder is defined by three key parameters: $(n, k, K)$.
\begin{description}
    \item[Code Rate ($R=k/n$)] The ratio of input bits ($k$) to output bits ($n$) per time step. Most practical codes use $k=1$ and have rates like 1/2 or 1/3.
    \item[Constraint Length ($K$)] The number of input bits that influence each output. The encoder is implemented with a shift register of length $m=K-1$, which represents its memory.
    \item[Generator Polynomials] A set of $n$ polynomials that define the XOR connections from the shift register taps to the output summer.
\end{description}
The number of states in the encoder's state machine is $2^{K-1}$. The complexity of the Viterbi decoder grows exponentially with $K$, which limits practical constraint lengths to around 7-9.

\paragraph{The NASA Standard Code}
One of the most famous and widely used codes is the NASA/JPL standard, with $K=7$ and rate $R=1/2$. Its generator polynomials are $g_1 = 171_8$ and $g_2 = 133_8$. This code has a free distance of $d_{\text{free}}=10$, providing a powerful error correction capability that became the benchmark for satellite and deep-space communications for over two decades.


\subsection{The Viterbi Algorithm}

The \keyterm{Viterbi algorithm} is a dynamic programming algorithm that performs \keyterm{maximum-likelihood sequence estimation}. It finds the single path through the code trellis that has the minimum "distance" (e.g., Hamming or Euclidean distance) to the received sequence.

\parhead{The Core Operation: Add-Compare-Select}
The algorithm works by moving through the trellis one time step at a time. At each state, it performs three operations:
\begin{enumerate}
    \item \textbf{Add:} For each of the two paths entering the current state, add the \keyterm{branch metric} (the error of that transition) to the cumulative \keyterm{path metric} of the preceding state.
    \item \textbf{Compare:} Compare the two resulting path metrics.
    \item \textbf{Select:} Choose the path with the smaller metric as the "survivor" for that state, and discard the other path.
\end{enumerate}
By systematically discarding the less likely paths at every step, the Viterbi algorithm avoids an exponential explosion in complexity, maintaining only one survivor path for each of the $2^{K-1}$ states. Once the end of the sequence is reached, the decoder performs a \keyterm{traceback} from the final state with the best metric to recover the single most likely transmitted sequence.

\begin{warningbox}
    \textbf{Soft-Decision Decoding:} The true power of the Viterbi algorithm is realised with \textbf{soft-decision} inputs. By using the raw analogue or multi-bit digital samples from the demodulator (instead of hard 0/1 decisions), the algorithm can weigh its decisions based on reliability. A sample that is close to the decision boundary contributes less to the path metric than a sample that is clearly a '0' or '1'. This provides a "free" coding gain of 2-3 dB over hard-decision decoding.
\end{warningbox}


\subsection{Performance and Coding Gain}

The performance of a convolutional code is determined by its \keyterm{free distance}, $d_{\text{free}}$, which is the minimum Hamming distance between any two distinct paths through the trellis. A larger free distance implies better error correction capability. The asymptotic coding gain is given by $G_c = 10\log_{10}(R \cdot d_{\text{free}})$.

\begin{table}[H]
    \centering
    \caption{Performance of Common Convolutional Codes (Rate 1/2)}
    \label{tab:conv-code-performance}
    \begin{tabular}{@{}cccc@{}}
        \toprule
        \tableheaderfont Constraint Length ($K$) & \tableheaderfont Free Distance ($d_{\text{free}}$) & \tableheaderfont Asymptotic Gain (Hard) & \tableheaderfont Approx. Gain (Soft) \\
        \midrule
        3 & 5 & 4.0 dB & 6.0 dB \\
        5 & 7 & 5.4 dB & 7.4 dB \\
        \textbf{7 (NASA Std.)} & \textbf{10} & \textbf{7.0 dB} & \textbf{9.0 dB} \\
        9 & 12 & 7.8 dB & 9.8 dB \\
        \bottomrule
    \end{tabular}
\end{table}


\begin{workedexample}{Deep Space Link with Convolutional Coding}
    \parhead{Problem} The Voyager 1 spacecraft transmits data from interstellar space. Given the extremely weak signal, analyse how convolutional coding makes communication possible.
    \parhead{System Parameters}
    \begin{itemize}
        \item Received $E_b/N_0$: Approx. \qty{2.5}{dB}.
        \item Modulation: BPSK.
        \item Target BER: $< 10^{-5}$.
        \item Code: NASA standard convolutional code ($K=7, R=1/2$) with soft-decision Viterbi decoding.
    \end{itemize}
    \parhead{Analysis}
    \begin{derivationsteps}
        \step \textbf{Check Uncoded Performance.} The required $E_b/N_0$ for uncoded BPSK to achieve a BER of $10^{-5}$ is 9.6 dB. With an available $E_b/N_0$ of only 2.5 dB, the uncoded link would fail completely (the BER would be worse than $10^{-1}$).
        
        \step \textbf{Apply Coding Gain.} The $K=7, R=1/2$ code with soft-decision decoding provides approximately 9.0 dB of coding gain at this BER.
        
        \step \textbf{Calculate Required Coded $E_b/N_0$.}
        \[ (\text{Required } E_b/N_0)_{\text{coded}} = (\text{Required } E_b/N_0)_{\text{uncoded}} - \text{Coding Gain} \]
        \[ (\text{Required } E_b/N_0)_{\text{coded}} = 9.6 \text{ dB} - 9.0 \text{ dB} = \textbf{\qty{0.6}{dB}} \]
        
        \step \textbf{Calculate Link Margin.}
        \[ \text{Link Margin} = (\text{Available } E_b/N_0) - (\text{Required } E_b/N_0)_{\text{coded}} = 2.5 - 0.6 = \textbf{\qty{1.9}{dB}} \]
    \end{derivationsteps}
    
    \parhead{Interpretation} The convolutional code is the enabling technology. It reduces the required signal strength by a factor of nearly eight, moving the performance requirement from an impossible 9.6 dB to an achievable 0.6 dB. The available 2.5 dB is therefore sufficient to close the link with a small but functional margin. (Note: Voyager actually uses an even more powerful concatenated code).
\end{workedexample}


\begin{importantbox}[title={Further Reading}]
    Convolutional codes and the Viterbi algorithm are foundational concepts in digital communications.
    \begin{description}
        \item[Block Codes] (\Cref{ch:block-codes}) such as Reed-Solomon are often used as an "outer code" in concatenation with an "inner" convolutional code to correct the burst errors that a Viterbi decoder can sometimes produce.
        \item[Turbo Codes] (\Cref{ch:turbo}) can be understood as a clever parallel concatenation of two simple convolutional codes, which, when decoded iteratively, achieves near-Shannon-limit performance.
        \item[Link Budget Analysis] (\Cref{ch:linkbudget}) is where the concept of coding gain is practically applied to determine if a link will close.
    \end{description}
\end{importantbox}